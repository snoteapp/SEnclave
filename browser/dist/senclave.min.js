var SEnclave=function(){"use strict";function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var t={exports:{}};!function(e){var t=function(){var e=String.fromCharCode,t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",o={};function n(e,t){if(!o[e]){o[e]={};for(var r=0;r<e.length;r++)o[e][e.charAt(r)]=r}return o[e][t]}var a={compressToBase64:function(e){if(null==e)return"";var r=a._compress(e,6,(function(e){return t.charAt(e)}));switch(r.length%4){default:case 0:return r;case 1:return r+"===";case 2:return r+"==";case 3:return r+"="}},decompressFromBase64:function(e){return null==e?"":""==e?null:a._decompress(e.length,32,(function(r){return n(t,e.charAt(r))}))},compressToUTF16:function(t){return null==t?"":a._compress(t,15,(function(t){return e(t+32)}))+" "},decompressFromUTF16:function(e){return null==e?"":""==e?null:a._decompress(e.length,16384,(function(t){return e.charCodeAt(t)-32}))},compressToUint8Array:function(e){for(var t=a.compress(e),r=new Uint8Array(2*t.length),o=0,n=t.length;o<n;o++){var i=t.charCodeAt(o);r[2*o]=i>>>8,r[2*o+1]=i%256}return r},decompressFromUint8Array:function(t){if(null==t)return a.decompress(t);for(var r=new Array(t.length/2),o=0,n=r.length;o<n;o++)r[o]=256*t[2*o]+t[2*o+1];var i=[];return r.forEach((function(t){i.push(e(t))})),a.decompress(i.join(""))},compressToEncodedURIComponent:function(e){return null==e?"":a._compress(e,6,(function(e){return r.charAt(e)}))},decompressFromEncodedURIComponent:function(e){return null==e?"":""==e?null:(e=e.replace(/ /g,"+"),a._decompress(e.length,32,(function(t){return n(r,e.charAt(t))})))},compress:function(t){return a._compress(t,16,(function(t){return e(t)}))},_compress:function(e,t,r){if(null==e)return"";var o,n,a,i={},s={},p="",c="",y="",h=2,u=3,f=2,d=[],E=0,l=0;for(a=0;a<e.length;a+=1)if(p=e.charAt(a),Object.prototype.hasOwnProperty.call(i,p)||(i[p]=u++,s[p]=!0),c=y+p,Object.prototype.hasOwnProperty.call(i,c))y=c;else{if(Object.prototype.hasOwnProperty.call(s,y)){if(y.charCodeAt(0)<256){for(o=0;o<f;o++)E<<=1,l==t-1?(l=0,d.push(r(E)),E=0):l++;for(n=y.charCodeAt(0),o=0;o<8;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1}else{for(n=1,o=0;o<f;o++)E=E<<1|n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n=0;for(n=y.charCodeAt(0),o=0;o<16;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1}0==--h&&(h=Math.pow(2,f),f++),delete s[y]}else for(n=i[y],o=0;o<f;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1;0==--h&&(h=Math.pow(2,f),f++),i[c]=u++,y=String(p)}if(""!==y){if(Object.prototype.hasOwnProperty.call(s,y)){if(y.charCodeAt(0)<256){for(o=0;o<f;o++)E<<=1,l==t-1?(l=0,d.push(r(E)),E=0):l++;for(n=y.charCodeAt(0),o=0;o<8;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1}else{for(n=1,o=0;o<f;o++)E=E<<1|n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n=0;for(n=y.charCodeAt(0),o=0;o<16;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1}0==--h&&(h=Math.pow(2,f),f++),delete s[y]}else for(n=i[y],o=0;o<f;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1;0==--h&&(h=Math.pow(2,f),f++)}for(n=2,o=0;o<f;o++)E=E<<1|1&n,l==t-1?(l=0,d.push(r(E)),E=0):l++,n>>=1;for(;;){if(E<<=1,l==t-1){d.push(r(E));break}l++}return d.join("")},decompress:function(e){return null==e?"":""==e?null:a._decompress(e.length,32768,(function(t){return e.charCodeAt(t)}))},_decompress:function(t,r,o){var n,a,i,s,p,c,y,h=[],u=4,f=4,d=3,E="",l=[],g={val:o(0),position:r,index:1};for(n=0;n<3;n+=1)h[n]=n;for(i=0,p=Math.pow(2,2),c=1;c!=p;)s=g.val&g.position,g.position>>=1,0==g.position&&(g.position=r,g.val=o(g.index++)),i|=(s>0?1:0)*c,c<<=1;switch(i){case 0:for(i=0,p=Math.pow(2,8),c=1;c!=p;)s=g.val&g.position,g.position>>=1,0==g.position&&(g.position=r,g.val=o(g.index++)),i|=(s>0?1:0)*c,c<<=1;y=e(i);break;case 1:for(i=0,p=Math.pow(2,16),c=1;c!=p;)s=g.val&g.position,g.position>>=1,0==g.position&&(g.position=r,g.val=o(g.index++)),i|=(s>0?1:0)*c,c<<=1;y=e(i);break;case 2:return""}for(h[3]=y,a=y,l.push(y);;){if(g.index>t)return"";for(i=0,p=Math.pow(2,d),c=1;c!=p;)s=g.val&g.position,g.position>>=1,0==g.position&&(g.position=r,g.val=o(g.index++)),i|=(s>0?1:0)*c,c<<=1;switch(y=i){case 0:for(i=0,p=Math.pow(2,8),c=1;c!=p;)s=g.val&g.position,g.position>>=1,0==g.position&&(g.position=r,g.val=o(g.index++)),i|=(s>0?1:0)*c,c<<=1;h[f++]=e(i),y=f-1,u--;break;case 1:for(i=0,p=Math.pow(2,16),c=1;c!=p;)s=g.val&g.position,g.position>>=1,0==g.position&&(g.position=r,g.val=o(g.index++)),i|=(s>0?1:0)*c,c<<=1;h[f++]=e(i),y=f-1,u--;break;case 2:return l.join("")}if(0==u&&(u=Math.pow(2,d),d++),h[y])E=h[y];else{if(y!==f)return null;E=a+a.charAt(0)}l.push(E),h[f++]=a+E.charAt(0),a=E,0==--u&&(u=Math.pow(2,d),d++)}}};return a}();null!=e?e.exports=t:"undefined"!=typeof angular&&null!=angular&&angular.module("LZString",[]).factory("LZString",(function(){return t}))}(t);var r=e(t.exports);const o=window.crypto||window.msCrypto,n=o.subtle||o.webkitSubtle,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=new Uint8Array(256),s="06092a864886f70d01050d",p="06092a864886f70d01050c",c="060960864801650304012e",y="060960864801650304011a",h="0609608648016503040106",u="060960864801650304012a",f="0609608648016503040116",d="0609608648016503040102",E="060960864801650304012c",l="0609608648016503040118",g="06086086480165030404",w="06082a864886f70d020b0500",b="06082a864886f70d020a0500",m="06082a864886f70d02090500",v="06082a864886f70d02070500",S="06092a864886f70d010101",A="06072a8648ce3d0201",x="06082a8648ce3d030107",T="06052b81040022",C="06052b81040023";const K={};function B(e,t){return e=Math.max(0,e||0),t=Math.min(Number.MAX_SAFE_INTEGER,t=t||Number.MAX_SAFE_INTEGER),Math.floor(crypto.getRandomValues(new Uint32Array(1))[0]/4294967296*(1+t-e))+e}K.clone=function(e){return window.structuredClone(e)},K.frozenClone=function(e){return Object.freeze(K.clone(e))},K.sleep=function(e){return new Promise((t=>setTimeout(t,e)))},K.unique=function(e,t){e=Math.max(1,e||20),t=Math.max(2,Math.min(62,t||62))-1;for(var r="",o=0;o<e;o++)r+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[B(0,t)];return r};const P=window.crypto||window.msCrypto,O=P.subtle||P.webkitSubtle,N={},R=new class{constructor(){for(let e=0;e<64;e++)i[a.charCodeAt(e)]=e}encodeAb(e){const t=new Uint8Array(e),r=t.length;let o="";for(let e=0;e<r;e+=3)o+=a[t[e]>>2],o+=a[(3&t[e])<<4|t[e+1]>>4],o+=a[(15&t[e+1])<<2|t[e+2]>>6],o+=a[63&t[e+2]];return r%3==2?o=o.substring(0,o.length-1)+"=":r%3==1&&(o=o.substring(0,o.length-2)+"=="),o}decodeAb(e){const t=e.length;let r,o,n,a,s=.75*e.length,p=0;"="===e[e.length-1]&&(s--,"="===e[e.length-2]&&s--);const c=new ArrayBuffer(s);let y=new Uint8Array(c);for(let s=0;s<t;s+=4)r=i[e.charCodeAt(s)],o=i[e.charCodeAt(s+1)],n=i[e.charCodeAt(s+2)],a=i[e.charCodeAt(s+3)],y[p++]=r<<2|o>>4,y[p++]=(15&o)<<4|n>>2,y[p++]=(3&n)<<6|63&a;return c}arrayBufferToString(e){if("object"!=typeof e)throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");return new TextDecoder("utf-8").decode(e)}stringToArrayBuffer(e){if("string"!=typeof e)throw new TypeError("Expected input of str to be a String");return new TextEncoder("utf-8").encode(e).buffer}arrayBufferToHexString(e){if("object"!=typeof e)throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");const t=new Uint8Array(e);let r,o="";for(let e=0;e<t.byteLength;e++)r=t[e].toString(16),r.length<2&&(r="0"+r),o+=r;return o}hexStringToArrayBuffer(e){if("string"!=typeof e)throw new TypeError("Expected input of hexString to be a String");if(e.length%2!=0)throw new RangeError("Expected string to be an even number of characters");const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}arrayBufferToBase64(e){if("object"!=typeof e)throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");return this.encodeAb(e)}base64ToArrayBuffer(e){if("string"!=typeof e)throw new TypeError("Expected input of b64 to be a Base64 String");return this.decodeAb(e)}decimalToHex(e,t){if("boolean"!=typeof(t=void 0!==t&&t))throw new TypeError("Expected input of unsigned to be a Boolean");let r=null;if("number"==typeof e)return t?(r=e.toString(16),r.length%2?"000"+r:"00"+r):(r=e.toString(16),r.length%2?"0"+r:r);if("string"==typeof e)return r=(e.length/2).toString(16),r.length%2?"0"+r:r;throw new TypeError("Expected input of d to be a Number or String")}addNewLines(e){let t="";for(;e.length>0;)t+=e.substring(0,64)+"\r\n",e=e.substring(64);return t}removeLines(e){return e.replace(/\r?\n|\r/g,"")}toAsn1(e,t,r,o,n,a,i){e=this.arrayBufferToHexString(e),t=this.arrayBufferToHexString(t),r=this.arrayBufferToHexString(r),o=this.decimalToHex(o,!0);const S={};switch(n){case"SHA-512":S.HASH_OID=w;break;case"SHA-384":S.HASH_OID=b;break;case"SHA-256":S.HASH_OID=m;break;case"SHA-1":S.HASH_OID=v}switch(a){case"AES-GCM":256===i?S.CIPHER_OID=c:192===i?S.CIPHER_OID=y:128===i&&(S.CIPHER_OID=h);break;case"AES-CBC":256===i?S.CIPHER_OID=u:192===i?S.CIPHER_OID=f:128===i&&(S.CIPHER_OID=d);break;case"AES-CFB":256===i?S.CIPHER_OID=E:192===i?S.CIPHER_OID=l:128===i&&(S.CIPHER_OID=g)}const A="02"+this.decimalToHex(o.length/2)+o,x="04"+this.decimalToHex(t)+t,T="04"+this.decimalToHex(r)+r,C="04"+(this.decimalToHex(e).length/2==2?"82":"81")+this.decimalToHex(e)+e;S.SEQUENCE_AES_CONTAINER="30"+this.decimalToHex(S.CIPHER_OID+T),S.SEQUENCE_HASH_CONTAINER="30"+this.decimalToHex(S.HASH_OID),S.SEQUENCE_PBKDF2_INNER_CONTAINER="30"+this.decimalToHex(x+A+S.SEQUENCE_HASH_CONTAINER+S.HASH_OID),S.SEQUENCE_PBKDF2_CONTAINER="30"+this.decimalToHex(p+S.SEQUENCE_PBKDF2_INNER_CONTAINER+x+A+S.SEQUENCE_HASH_CONTAINER+S.HASH_OID),S.SEQUENCE_PBES2_INNER_CONTAINER="30"+this.decimalToHex(S.SEQUENCE_PBKDF2_CONTAINER+p+S.SEQUENCE_PBKDF2_INNER_CONTAINER+x+A+S.SEQUENCE_HASH_CONTAINER+S.HASH_OID+S.SEQUENCE_AES_CONTAINER+S.CIPHER_OID+T),S.SEQUENCE_PBES2_CONTAINER="30"+this.decimalToHex(s+S.SEQUENCE_PBES2_INNER_CONTAINER+S.SEQUENCE_PBKDF2_CONTAINER+p+S.SEQUENCE_PBKDF2_INNER_CONTAINER+x+A+S.SEQUENCE_HASH_CONTAINER+S.HASH_OID+S.SEQUENCE_AES_CONTAINER+S.CIPHER_OID+T);const K=S.SEQUENCE_PBES2_CONTAINER+s+S.SEQUENCE_PBES2_INNER_CONTAINER+S.SEQUENCE_PBKDF2_CONTAINER+p+S.SEQUENCE_PBKDF2_INNER_CONTAINER+x+A+S.SEQUENCE_HASH_CONTAINER+S.HASH_OID+S.SEQUENCE_AES_CONTAINER+S.CIPHER_OID+T,B=this.decimalToHex(K+C),P="30"+(B.length/2==2?"82":"81")+B+K+C,O=this.hexStringToArrayBuffer(P);let N=this.arrayBufferToBase64(O);return N=this.addNewLines(N),N="-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n"+N+"-----END ENCRYPTED PRIVATE KEY-----",N}fromAsn1(e){e=(e=(e=this.removeLines(e)).replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","")).replace("-----END ENCRYPTED PRIVATE KEY-----",""),e=this.base64ToArrayBuffer(e);const t={},r=this.arrayBufferToHexString(e);t.data=r,t.data.includes(s)&&t.data.includes(p)&&(t.valid=!0),t.saltBegin=t.data.indexOf(p)+28,t.data.includes(c)?(t.cipher="AES-GCM",t.length=256,t.ivBegin=t.data.indexOf(c)+24):t.data.includes(y)?(t.cipher="AES-GCM",t.length=192,t.ivBegin=t.data.indexOf(y)+24):t.data.includes(h)?(t.cipher="AES-GCM",t.length=128,t.ivBegin=t.data.indexOf(h)+24):t.data.includes(u)?(t.cipher="AES-CBC",t.length=256,t.ivBegin=t.data.indexOf(u)+24):t.data.includes(f)?(t.cipher="AES-CBC",t.length=192,t.ivBegin=t.data.indexOf(f)+24):t.data.includes(d)?(t.cipher="AES-CBC",t.length=128,t.ivBegin=t.data.indexOf(d)+24):t.data.includes(E)?(t.cipher="AES-CFB",t.length=256,t.ivBegin=t.data.indexOf(E)+24):t.data.includes(l)?(t.cipher="AES-CFB",t.length=192,t.ivBegin=t.data.indexOf(l)+24):t.data.includes(g)&&(t.cipher="AES-CFB",t.length=128,t.ivBegin=t.data.indexOf(g)+22),t.data.includes(w)?t.hash="SHA-512":t.data.includes(b)?t.hash="SHA-384":t.data.includes(m)?t.hash="SHA-256":t.data.includes(v)&&(t.hash="SHA-1"),t.saltLength=parseInt(t.data.substr(t.saltBegin,2),16),t.ivLength=parseInt(t.data.substr(t.ivBegin,2),16),t.salt=t.data.substr(t.saltBegin+2,2*t.saltLength),t.iv=t.data.substr(t.ivBegin+2,2*t.ivLength),t.iterBegin=t.saltBegin+4+2*t.saltLength,t.iterLength=parseInt(t.data.substr(t.iterBegin,2),16),t.iter=parseInt(t.data.substr(t.iterBegin+2,2*t.iterLength),16),t.sequencePadding="81"===t.data.substr(2,2)?8:10,t.parametersPadding="81"===t.data.substr(2,2)?12:16,t.sequenceLength=parseInt(t.data.substr(t.sequencePadding,2),16),t.encryptedDataBegin=t.parametersPadding+2*t.sequenceLength,t.encryptedDataPadding="81"===t.data.substr(t.encryptedDataBegin-2,2)?2:4,t.encryptedDataLength=parseInt(t.data.substr(t.encryptedDataBegin,6),16),t.encryptedData=t.data.substr(t.encryptedDataBegin+t.encryptedDataPadding,2*t.encryptedDataLength);return{salt:this.hexStringToArrayBuffer(t.salt),iv:this.hexStringToArrayBuffer(t.iv),cipher:t.cipher,length:t.length,hash:t.hash,iter:t.iter,encryptedData:this.hexStringToArrayBuffer(t.encryptedData)}}cryptoPrivateToPem(e){const t=this;return new Promise(((r,o)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");n.exportKey("pkcs8",e).then((e=>{const o=t.arrayBufferToBase64(e);let n=t.addNewLines(o);n="-----BEGIN PRIVATE KEY-----\r\n"+n+"-----END PRIVATE KEY-----",r(n)})).catch((e=>{o(e)}))}))}pemPrivateToCrypto(e,t){const r=this;return void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((o,a)=>{if("string"!=typeof e)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");e=(e=e.replace("-----BEGIN PRIVATE KEY-----","")).replace("-----END PRIVATE KEY-----","");const i=r.removeLines(e),s=r.base64ToArrayBuffer(i),p=r.arrayBufferToHexString(s),c={};if(p.includes(A)){if(t.name=void 0!==t.name?t.name:"ECDH","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");let e=null;if(p.includes(x)?e="P-256":p.includes(T)?e="P-384":p.includes(C)&&(e="P-521"),"ECDH"===t.name)t.usages=void 0!==t.usages?t.usages:["deriveKey","deriveBits"];else{if("ECDSA"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["sign"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");c.name=t.name,c.namedCurve=e}else{if(!p.includes(S))throw new TypeError("Expected input of pem is not a valid private key");if(t.name=void 0!==t.name?t.name:"RSA-OAEP",t.hash=void 0!==t.hash?t.hash:"SHA-512","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===t.name)t.usages=void 0!==t.usages?t.usages:["decrypt","unwrapKey"];else{if("RSA-PSS"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["sign"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");c.name=t.name,c.hash={},c.hash.name=t.hash}n.importKey("pkcs8",s,c,t.isExtractable,t.usages).then((e=>{o(e)})).catch((e=>{a(e)}))}))}cryptoPublicToPem(e){const t=this;return new Promise(((r,o)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");n.exportKey("spki",e).then((e=>{const o=t.arrayBufferToBase64(e);let n=t.addNewLines(o);n="-----BEGIN PUBLIC KEY-----\r\n"+n+"-----END PUBLIC KEY-----",r(n)})).catch((e=>{o(e)}))}))}pemPublicToCrypto(e,t){const r=this;return void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((o,a)=>{if("string"!=typeof e)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");e=(e=e.replace("-----BEGIN PUBLIC KEY-----","")).replace("-----END PUBLIC KEY-----","");const i=r.removeLines(e),s=r.base64ToArrayBuffer(i),p=r.arrayBufferToHexString(s),c={};if(p.includes(A)){if(t.name=void 0!==t.name?t.name:"ECDH","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");let e=null;if(p.includes(x)?e="P-256":p.includes(T)?e="P-384":p.includes(C)&&(e="P-521"),"ECDH"===t.name)t.usages=void 0!==t.usages?t.usages:[];else{if("ECDSA"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["verify"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");c.name=t.name,c.namedCurve=e}else{if(!p.includes(S))throw new TypeError("Expected input of pem is not a valid public key");if(t.name=void 0!==t.name?t.name:"RSA-OAEP",t.hash=void 0!==t.hash?t.hash:"SHA-512","string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===t.name)t.usages=void 0!==t.usages?t.usages:["encrypt","wrapKey"];else{if("RSA-PSS"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");t.usages=void 0!==t.usages?t.usages:["verify"]}if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");c.name=t.name,c.hash={},c.hash.name=t.hash}n.importKey("spki",s,c,t.isExtractable,t.usages).then((e=>{o(e)})).catch((e=>{a(e)}))}))}cryptoToBase64(e,t){const r=this;let o=null;switch(e.type){case"secret":o="raw";break;case"private":o="pkcs8";break;case"public":o="spki"}return t=void 0!==t?t:o,new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of type to be a String");n.exportKey(o,e).then((e=>{const t=r.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}))}base64ToCrypto(e,t){const r=this;return void 0===t&&(t={}),t.name=void 0!==t.name?t.name:"AES-GCM",t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((o,a)=>{if("string"!=typeof e)throw new TypeError("Expected input of key to be a Base64 String");if("string"!=typeof t.name)throw new TypeError("Expected input of options.name to be a String");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const i={};if(i.name=t.name,"AES-GCM"===t.name||"AES-CBC"===t.name){if(t.type=void 0!==t.type?t.type:"raw",t.length=void 0!==t.length?t.length:256,t.usages=void 0!==t.usages?t.usages:["encrypt","decrypt","wrapKey","unwrapKey"],"number"!=typeof t.length)throw new TypeError("Expected input of options.length to be a Number")}else if("ECDH"===t.name){if(t.type=void 0!==t.type?t.type:"pkcs8",t.namedCurve=void 0!==t.namedCurve?t.namedCurve:"P-256",t.usages=void 0!==t.usages?t.usages:["deriveKey","deriveBits"],"string"!=typeof t.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");i.namedCurve=t.namedCurve}else if("ECDSA"===t.name){if(t.type=void 0!==t.type?t.type:"pkcs8",t.namedCurve=void 0!==t.namedCurve?t.namedCurve:"P-256",t.usages=void 0!==t.usages?t.usages:["sign"],"string"!=typeof t.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");i.namedCurve=t.namedCurve}else if("RSA-OAEP"===t.name){if(t.type=void 0!==t.type?t.type:"pkcs8",t.hash=void 0!==t.hash?t.hash:"SHA-512",t.usages=void 0!==t.usages?t.usages:["decrypt","unwrapKey"],"string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");i.hash={},i.hash.name=t.hash}else{if("RSA-PSS"!==t.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");if(t.type=void 0!==t.type?t.type:"pkcs8",t.hash=void 0!==t.hash?t.hash:"SHA-512",t.usages=void 0!==t.usages?t.usages:["sign"],"string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");i.hash={},i.hash.name=t.hash}if("string"!=typeof t.type)throw new TypeError("Expected input of options.type to be a String");if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");const s=r.base64ToArrayBuffer(e);n.importKey(t.type,s,i,t.isExtractable,t.usages).then((e=>{o(e)})).catch((e=>{a(e)}))}))}getRSAKeyPair(e,t,r,o,a){return e=void 0!==e?e:2048,t=void 0!==t?t:"SHA-512",r=void 0!==r?r:"RSA-OAEP",a=void 0===a||a,new Promise(((i,s)=>{if("number"!=typeof e)throw new TypeError("Expected input of modulusLength to be a Number");if("string"!=typeof t)throw new TypeError("Expected input of hash expected to be a String");if("string"!=typeof r)throw new TypeError("Expected input of paddingScheme to be a String");if("boolean"!=typeof a)throw new TypeError("Expected input of isExtractable to be a Boolean");if("RSA-OAEP"===r)o=void 0!==o?o:["encrypt","decrypt","wrapKey","unwrapKey"];else{if("RSA-PSS"!==r)throw new TypeError("Expected input of paddingScheme is not a valid padding scheme");o=void 0!==o?o:["sign","verify"]}if("object"!=typeof o)throw new TypeError("Expected input of usages to be an Array");n.generateKey({name:r,modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:t}},a,o).then((e=>{i(e)})).catch((e=>{s(e)}))}))}rsaEncrypt(e,t){const r=this;return new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");n.encrypt({name:"RSA-OAEP"},e,t).then((e=>{const t=r.arrayBufferToBase64(e);o(t)})).catch((e=>{a(e)}))}))}rsaDecrypt(e,t){const r=this;return new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("string"!=typeof t)throw new TypeError("Expected input of encryptedData to be a Base64 String");const i=r.base64ToArrayBuffer(t);n.decrypt({name:"RSA-OAEP"},e,i).then((e=>{o(e)})).catch((e=>{a(e)}))}))}getECKeyPair(e,t,r,o){return e=void 0!==e?e:"P-256",t=void 0!==t?t:"ECDH",o=void 0===o||o,new Promise(((a,i)=>{if("string"!=typeof e)throw new TypeError("Expected input of curve to be a String");if("string"!=typeof t)throw new TypeError("Expected input of type to be a String");if("boolean"!=typeof o)throw new TypeError("Expected input of isExtractable to be a Boolean");if("ECDH"===t)r=void 0!==r?r:["deriveKey","deriveBits"];else{if("ECDSA"!==t)throw new TypeError("Expected input of type is not a valid algorithm type");r=void 0!==r?r:["sign","verify"]}if("object"!=typeof r)throw new TypeError("Expected input of usages to be an Array");n.generateKey({name:t,namedCurve:e},o,r).then((e=>{a(e)})).catch((e=>{i(e)}))}))}getPublicKey(e,t){return void 0===t&&(t={}),t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((r,o)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey must be a CryptoKey Object of type private");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");n.exportKey("jwk",e).then((a=>{const i={};switch(i.name=e.algorithm.name,e.algorithm.name){case"ECDH":if(delete a.d,a.key_ops=[],t.usages=void 0!==t.usages?t.usages:[],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");i.namedCurve=e.algorithm.namedCurve;break;case"ECDSA":if(delete a.d,a.key_ops=["verify"],t.usages=void 0!==t.usages?t.usages:["verify"],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");i.namedCurve=e.algorithm.namedCurve;break;case"RSA-OAEP":if(delete a.d,delete a.dp,delete a.dq,delete a.p,delete a.q,delete a.qi,a.key_ops=["encrypt","wrapKey"],t.usages=void 0!==t.usages?t.usages:["encrypt","wrapKey"],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");i.hash={},i.hash.name=e.algorithm.hash.name;break;case"RSA-PSS":if(delete a.d,delete a.dp,delete a.dq,delete a.p,delete a.q,delete a.qi,a.key_ops=["verify"],t.usages=void 0!==t.usages?t.usages:["verify"],"object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");i.hash={},i.hash.name=e.algorithm.hash.name;break;default:throw new TypeError("Expected input of privateKey is not a valid private key")}n.importKey("jwk",a,i,t.isExtractable,t.usages).then((e=>{r(e)})).catch((e=>{o(e)}))})).catch((e=>{o(e)}))}))}encryptPrivateKey(e,t,r,a,i,s){const p=this;return r=void 0!==r?r:64e3,a=void 0!==a?a:"SHA-512",i=void 0!==i?i:"AES-GCM",s=void 0!==s?s:256,new Promise(((c,y)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("string"!=typeof t)throw new TypeError("Expected input of passphrase to be a String");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof a)throw new TypeError("Expected input of hash to be a String");if("string"!=typeof i)throw new TypeError("Expected input of cipher to be a String");if("number"!=typeof s)throw new TypeError("Expected input of length to be a Number");let h=null;switch(i){case"AES-GCM":h=12;break;case"AES-CBC":case"AES-CFB":h=16}const u=o.getRandomValues(new Uint8Array(16)),f=o.getRandomValues(new Uint8Array(h)),d=p.stringToArrayBuffer(t);n.importKey("raw",d,{name:"PBKDF2"},!1,["deriveKey"]).then((t=>{n.deriveKey({name:"PBKDF2",salt:u,iterations:r,hash:a},t,{name:i,length:s},!1,["wrapKey"]).then((t=>{n.wrapKey("pkcs8",e,t,{name:i,iv:f,tagLength:128}).then((e=>{const t=p.toAsn1(e,u,f,r,a,i,s);c(t)})).catch((e=>{y(e)}))})).catch((e=>{y(e)}))})).catch((e=>{y(e)}))}))}decryptPrivateKey(e,t,r){const o=this;return void 0===r&&(r={}),r.name=void 0!==r.name?r.name:"ECDH",r.isExtractable=void 0===r.isExtractable||r.isExtractable,new Promise(((a,i)=>{if("string"!=typeof e)throw new TypeError("Expected input of encryptedPrivateKey to be a Base64 String");if("string"!=typeof t)throw new TypeError("Expected input of passphrase to be a String");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const s=this.fromAsn1(e),p={};if(p.name=r.name,"ECDH"===r.name){if(r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["deriveKey","deriveBits"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.namedCurve=r.namedCurve}else if("ECDSA"===r.name){if(r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.namedCurve=r.namedCurve}else if("RSA-OAEP"===r.name){if(r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["decrypt","unwrapKey"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.hash={},p.hash.name=r.hash}else{if("RSA-PSS"!==r.name)throw new TypeError("Expected input of encryptedPrivateKey is not a valid encrypted private key");if(r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");p.hash={},p.hash.name=r.hash}const c=o.stringToArrayBuffer(t);n.importKey("raw",c,{name:"PBKDF2"},!1,["deriveKey"]).then((e=>{n.deriveKey({name:"PBKDF2",salt:s.salt,iterations:s.iter,hash:s.hash},e,{name:s.cipher,length:s.length},!1,["unwrapKey"]).then((e=>{n.unwrapKey("pkcs8",s.encryptedData,e,{name:s.cipher,iv:s.iv,tagLength:128},p,r.isExtractable,r.usages).then((e=>{a(e)})).catch((e=>{i(e)}))})).catch((e=>{i(e)}))})).catch((e=>{i(e)}))}))}keyAgreement(e,t,r){return void 0===r&&(r={}),r.bitLength=void 0!==r.bitLength?r.bitLength:256,r.hkdfHash=void 0!==r.hkdfHash?r.hkdfHash:"SHA-512",r.hkdfSalt=void 0!==r.hkdfSalt?r.hkdfSalt:new Uint8Array,r.hkdfInfo=void 0!==r.hkdfInfo?r.hkdfInfo:new Uint8Array,r.cipher=void 0!==r.cipher?r.cipher:"AES-GCM",r.length=void 0!==r.length?r.length:256,r.usages=void 0!==r.usages?r.usages:["encrypt","decrypt","unwrapKey","wrapKey"],r.isExtractable=void 0===r.isExtractable||r.isExtractable,new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(t)&&"public"!==t.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("number"!=typeof r.bitLength)throw new TypeError("Expected input of options.bitLength to be a Number");if("string"!=typeof r.hkdfHash)throw new TypeError("Expected input of options.hkdfHash to be a String");if("object"!=typeof r.hkdfSalt)throw new TypeError("Expected input of options.hkdfSalt to be an ArrayBuffer");if("object"!=typeof r.hkdfInfo)throw new TypeError("Expected input of options.hkdfInfo to be an ArrayBuffer");if("string"!=typeof r.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("number"!=typeof r.length)throw new TypeError("Expected input of options.length to be a Number");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");n.deriveBits({name:"ECDH",namedCurve:t.algorithm.namedCurve,public:t},e,r.bitLength).then((e=>{n.importKey("raw",e,{name:"HKDF"},!1,["deriveKey"]).then((e=>{n.deriveKey({name:"HKDF",hash:{name:r.hkdfHash},salt:r.hkdfSalt,info:r.hkdfInfo},e,{name:r.cipher,length:r.length},r.isExtractable,r.usages).then((e=>{o(e)})).catch((e=>{a(e)}))})).catch((e=>{a(e)}))})).catch((e=>{a(e)}))}))}getSharedKey(e,t){return e=void 0!==e?e:256,void 0===t&&(t={}),t.cipher=void 0!==t.cipher?t.cipher:"AES-GCM",t.usages=void 0!==t.usages?t.usages:["encrypt","decrypt","wrapKey","unwrapKey"],t.isExtractable=void 0===t.isExtractable||t.isExtractable,new Promise(((r,o)=>{if("number"!=typeof e)throw new TypeError("Expected input of length to be a Number");if("string"!=typeof t.cipher)throw new TypeError("Expected input of options.cipher expected to be a String");if("object"!=typeof t.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof t.isExtractable)throw new TypeError("Expected input of options.isExtractable expected to be a Boolean");n.generateKey({name:t.cipher,length:e},t.isExtractable,t.usages).then((e=>{r(e)})).catch((e=>{o(e)}))}))}encryptKey(e,t){const r=this;return new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of wrappingKey to be a CryptoKey Object");if("[object CryptoKey]"!==Object.prototype.toString.call(t))throw new TypeError("Expected input of key to be a CryptoKey Object");let s=null;switch(t.type){case"secret":s="raw";break;case"private":s="pkcs8";break;case"public":s="spki"}if("secret"===e.type){let p=null;if("AES-GCM"===e.algorithm.name)p=o.getRandomValues(new Uint8Array(12));else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the wrappingKey is not supported");p=o.getRandomValues(new Uint8Array(16))}n.wrapKey(s,t,e,{name:e.algorithm.name,iv:p,tagLength:128}).then((e=>{const t=r.arrayBufferToBase64(p)+r.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}else{if("RSA-OAEP"!==e.algorithm.name)throw new TypeError("Expected input of wrappingKey is not a supported key");if("public"!==e.type)throw new TypeError("Expected input of wrappingKey to be a CryptoKey Object of type public");n.wrapKey(s,t,e,{name:"RSA-OAEP",hash:{name:e.algorithm.hash.name}}).then((e=>{const t=r.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}}))}decryptKey(e,t,r){const o=this;return void 0===r&&(r={}),r.name=void 0!==r.name?r.name:"AES-GCM",r.isExtractable=void 0===r.isExtractable||r.isExtractable,new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of unwrappingKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of encryptedKey to be a Base64 String");if("string"!=typeof r.name)throw new TypeError("Expected input of options.name to be a String");if("boolean"!=typeof r.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const s={};if(s.name=r.name,"AES-GCM"===r.name||"AES-CBC"===r.name){if(r.type=void 0!==r.type?r.type:"raw",r.length=void 0!==r.length?r.length:256,r.usages=void 0!==r.usages?r.usages:["encrypt","decrypt","wrapKey","unwrapKey"],"number"!=typeof r.length)throw new TypeError("Expected input of options.length to be a Number")}else if("ECDH"===r.name){if(r.type=void 0!==r.type?r.type:"pkcs8",r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["deriveKey","deriveBits"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");s.namedCurve=r.namedCurve}else if("ECDSA"===r.name){if(r.type=void 0!==r.type?r.type:"pkcs8",r.namedCurve=void 0!==r.namedCurve?r.namedCurve:"P-256",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");s.namedCurve=r.namedCurve}else if("RSA-OAEP"===r.name){if(r.type=void 0!==r.type?r.type:"pkcs8",r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["decrypt","unwrapKey"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");s.hash={},s.hash.name=r.hash}else{if("RSA-PSS"!==r.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");if(r.type=void 0!==r.type?r.type:"pkcs8",r.hash=void 0!==r.hash?r.hash:"SHA-512",r.usages=void 0!==r.usages?r.usages:["sign"],"string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");s.hash={},s.hash.name=r.hash}if("string"!=typeof r.type)throw new TypeError("Expected input of options.type to be a String");if("object"!=typeof r.usages)throw new TypeError("Expected input of options.usages to be an Array");if("secret"===e.type){let p=null,c=null;if("AES-GCM"===e.algorithm.name)p=t.substring(0,16),c=t.substring(16);else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the wrappingKey is not supported");p=t.substring(0,24),c=t.substring(24)}const y=o.base64ToArrayBuffer(p),h=o.base64ToArrayBuffer(c);n.unwrapKey(r.type,h,e,{name:e.algorithm.name,iv:y,tagLength:128},s,r.isExtractable,r.usages).then((e=>{a(e)})).catch((e=>{i(e)}))}else{if("RSA-OAEP"!==e.algorithm.name)throw new TypeError("Expected input of unwrappingKey is not a supported key");{if("private"!==e.type)throw new TypeError("Expected input of unwrappingKey to be a CryptoKey Object of type private");const p=o.base64ToArrayBuffer(t);n.unwrapKey(r.type,p,e,{name:"RSA-OAEP",modulusLength:e.algorithm.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:e.algorithm.hash.name}},s,r.isExtractable,r.usages).then((e=>{a(e)})).catch((e=>{i(e)}))}}}))}signKey(e,t,r){const o=this;return void 0===r&&(r={}),new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(t))throw new TypeError("Expected input of key to be a CryptoKey Object");n.exportKey("raw",t).then((t=>{if("ECDSA"===e.algorithm.name){if(r.hash=void 0!==r.hash?r.hash:"SHA-512","string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");n.sign({name:"ECDSA",hash:{name:r.hash}},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of privateKey is not a valid private key");if(r.saltLength=void 0!==r.saltLength?r.saltLength:128,"number"!=typeof r.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");n.sign({name:"RSA-PSS",saltLength:r.saltLength},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}})).catch((e=>{i(e)}))}))}verifyKey(e,t,r,o){const a=this;return void 0===o&&(o={}),new Promise(((i,s)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("[object CryptoKey]"!==Object.prototype.toString.call(t))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof r)throw new TypeError("Expected input of signature to be a Base64 String");const p=a.base64ToArrayBuffer(r);n.exportKey("raw",t).then((t=>{if("ECDSA"===e.algorithm.name){if(o.hash=void 0!==o.hash?o.hash:"SHA-512","string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");n.verify({name:"ECDSA",hash:{name:o.hash}},e,p,t).then((e=>{i(e)})).catch((e=>{s(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of publicKey is not a valid public key");n.verify({name:"RSA-PSS",saltLength:128},e,p,t).then((e=>{i(e)})).catch((e=>{s(e)}))}})).catch((e=>{s(e)}))}))}sign(e,t,r){const o=this;return void 0===r&&(r={}),new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");if("ECDSA"===e.algorithm.name){if(r.hash=void 0!==r.hash?r.hash:"SHA-512","string"!=typeof r.hash)throw new TypeError("Expected input of options.hash to be a String");n.sign({name:"ECDSA",hash:{name:r.hash}},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of privateKey is not a valid private key");if(r.saltLength=void 0!==r.saltLength?r.saltLength:128,"number"!=typeof r.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");n.sign({name:"RSA-PSS",saltLength:r.saltLength},e,t).then((e=>{const t=o.arrayBufferToBase64(e);a(t)})).catch((e=>{i(e)}))}}))}verify(e,t,r,o){const a=this;return void 0===o&&(o={}),new Promise(((i,s)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");if("string"!=typeof r)throw new TypeError("Expected input of signature to be a Base64 String");const p=a.base64ToArrayBuffer(r);if("ECDSA"===e.algorithm.name){if(o.hash=void 0!==o.hash?o.hash:"SHA-512","string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");n.verify({name:"ECDSA",hash:{name:o.hash}},e,p,t).then((e=>{i(e)})).catch((e=>{s(e)}))}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of publicKey is not a valid public key");n.verify({name:"RSA-PSS",saltLength:128},e,p,t).then((e=>{i(e)})).catch((e=>{s(e)}))}}))}encrypt(e,t){const r=this;return new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("object"!=typeof t)throw new TypeError("Expected input of data to be an ArrayBuffer");let s=null;if("AES-GCM"===e.algorithm.name)s=o.getRandomValues(new Uint8Array(12));else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the sharedKey is not supported");s=o.getRandomValues(new Uint8Array(16))}n.encrypt({name:e.algorithm.name,iv:s,tagLength:128},e,t).then((e=>{const t=r.arrayBufferToBase64(s),o=r.arrayBufferToBase64(e);a(t+o)})).catch((e=>{i(e)}))}))}decrypt(e,t,r){const o=this;return void 0===r&&(r={}),r.cipher=void 0!==r.cipher?r.cipher:"AES-GCM",new Promise(((a,i)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("string"!=typeof t)throw new TypeError("Expected input of encryptedData to be a String");if("string"!=typeof r.cipher)throw new TypeError("Expected input of options.cipher to be a String");let s=null,p=null;if("AES-GCM"===r.cipher)s=t.substring(0,16),p=t.substring(16);else{if("AES-CBC"!==r.cipher)throw new TypeError("Cipher mode of the sharedKey is not supported");s=t.substring(0,24),p=t.substring(24)}const c=o.base64ToArrayBuffer(s),y=o.base64ToArrayBuffer(p);n.decrypt({name:r.cipher,iv:c,tagLength:128},e,y).then((e=>{a(e)})).catch((e=>{i(e)}))}))}derivePassphraseKey(e,t,r,o){const a=this;return r=void 0!==r?r:64e3,void 0===o&&(o={}),o.hash=void 0!==o.hash?o.hash:"SHA-512",o.length=void 0!==o.length?o.length:256,o.cipher=void 0!==o.cipher?o.cipher:"AES-GCM",o.usages=void 0!==o.usages?o.usages:["encrypt","decrypt","wrapKey","unwrapKey"],o.isExtractable=void 0===o.isExtractable||o.isExtractable,new Promise(((i,s)=>{if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!=typeof t)throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");if("number"!=typeof o.length)throw new TypeError("Expected input of options.length to be a Number");if("string"!=typeof o.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("object"!=typeof o.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof o.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");const p=a.stringToArrayBuffer(e);n.importKey("raw",p,{name:"PBKDF2"},!1,["deriveKey"]).then((e=>{n.deriveKey({name:"PBKDF2",salt:t,iterations:r,hash:{name:o.hash}},e,{name:o.cipher,length:o.length},o.isExtractable,o.usages).then((e=>{i(e)})).catch((e=>{s(e)}))})).catch((e=>{s(e)}))}))}hashPassphrase(e,t,r,o){const a=this;return r=void 0!==r?r:64e3,void 0===o&&(o={}),o.hash=void 0!==o.hash?o.hash:"SHA-512",o.length=void 0!==o.length?o.length:256,o.cipher=void 0!==o.cipher?o.cipher:"AES-GCM",o.usages=void 0!==o.usages?o.usages:["encrypt","decrypt","wrapKey","unwrapKey"],o.isExtractable=void 0===o.isExtractable||o.isExtractable,new Promise(((i,s)=>{if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!=typeof t)throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof r)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof o.hash)throw new TypeError("Expected input of options.hash to be a String");if("number"!=typeof o.length)throw new TypeError("Expected input of options.length to be a Number");if("string"!=typeof o.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("object"!=typeof o.usages)throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof o.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");a.derivePassphraseKey(e,t,r,o).then((e=>{n.exportKey("raw",e).then((e=>{const t=a.arrayBufferToHexString(e);i(t)})).catch((e=>{s(e)}))})).catch((e=>{s(e)}))}))}getFingerprint(e,t){const r=this;return void 0===t&&(t={}),t.hash="undefined"!=typeof hash?hash:"SHA-512",t.isBuffer=void 0!==t.isBuffer&&t.isBuffer,new Promise(((o,a)=>{if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof t.hash)throw new TypeError("Expected input of options.hash to be a String");if("boolean"!=typeof t.isBuffer)throw new TypeError("Expected input of options.isBuffer to be a Boolean");let i=null;switch(e.type){case"secret":i="raw";break;case"private":i="pkcs8";break;case"public":i="spki"}n.exportKey(i,e).then((e=>{n.digest({name:t.hash},e).then((e=>{if(t.isBuffer)o(e);else{const t=r.arrayBufferToHexString(e);o(t)}})).catch((e=>{a(e)}))})).catch((e=>{a(e)}))}))}getRandomBytes(e){return e=void 0!==e?e:16,new Promise(((t,r)=>{if("number"!=typeof e)throw new TypeError("Expected input of size to be a Number");t(o.getRandomValues(new Uint8Array(e)))}))}},H={},j={},I={};function k(e){for(var t in e)delete e[t]}function _(){k(I),k(j),Object.assign(I,{version:1,user:!1,state:"uninitialized",deviceId:K.unique(30),sessionId:K.unique(30)})}function D(e){e!=I.state&&(I.state=e,console.info("SEnclave.state",e))}function L(){for(var e=[],t=0;t<3;t++)e.push(K.unique(6,32));return e.join("-")}function U(e){return e.replace(/^--.*--$/gm,"").replace(/[\r\n]/g,"")}async function M(e,t){var r=await R.getRSAKeyPair(2048,"SHA-512","RSA-OAEP",["encrypt","decrypt","wrapKey","unwrapKey"],!0),o=await R.encryptPrivateKey(r.privateKey,t,800100,"SHA-512","AES-GCM",256);o=U(o);var n=await R.cryptoPublicToPem(r.publicKey);n=U(n);var a=await async function(e,t){var r=R.stringToArrayBuffer(e),o=await R.hashPassphrase(t,r,800102,{hash:"SHA-512",length:256,cipher:"AES-GCM",usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!0});return R.arrayBufferToBase64(R.hexStringToArrayBuffer(o))}(e,t),i=L(),s=L(),p=await R.cryptoPrivateToPem(r.privateKey);p=U(p);var c=JSON.stringify({ts:Date.now(),hPwd:a,iPrvKey:p}),y=[i,s].join("-"),h=R.stringToArrayBuffer(e),u=await R.derivePassphraseKey(y,h,800100,{hash:"SHA-512",length:256,cipher:"AES-GCM",usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!1}),f=await R.encrypt(u,R.stringToArrayBuffer(c)),d=await R.getSharedKey(256,{cipher:"AES-GCM",usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!0});return{hPwd:a,ePubKey:n,ePrvKey:o,cRecKey:i,sRecKey:s,eShrKey:await R.encryptKey(r.publicKey,d),iShrKey:d,eRec:f}}function G(){for(var e=0,t=[],r=0,o=arguments.length;r<o;r++){var n=!1,a=arguments[r],i=typeof a;"number"===i?n=new Uint8Array([a]):"object"===i&&("[object ArrayBuffer]"===(i=Object.prototype.toString.call(a))?n=new Uint8Array(a):"[object Uint8Array]"===i&&(n=a)),n&&(e+=n.length,t.push(n))}var s=new Uint8Array(e),p=0;for(r=0,o=t.length;r<o;r++){n=t[r];s.set(n,p),p+=n.length}return s.buffer}async function F(e,t){var r=null;try{let t=P.getRandomValues(new Uint8Array(12));r=G(t,await O.encrypt({name:"AES-GCM",iv:t,tagLength:128},this._key,e))}catch(e){console.error(e)}return r}async function Q(e,t){var r=null;try{let t=new Uint8Array(e.slice(0,12));e=e.slice(12),r=await O.decrypt({name:"AES-GCM",iv:t,tagLength:128},this._key,e)}catch{}return r}async function V(e){e=JSON.stringify(e);var t,o=2,n=null;if(2===o)n=r.compressToUint8Array(e);else o=0,n=R.stringToArrayBuffer(e);return null==n?null:(e=G(o,n),null===(t=await this.encryptRaw(e))?null:R.arrayBufferToBase64(t))}async function Y(e){var t=null;try{var o=await this.decryptRaw(R.base64ToArrayBuffer(e)),n=new Uint8Array(o.slice(0,1))[0];o=o.slice(1);var a=null;if(2===n)a=r.decompressFromUint8Array(new Uint8Array(o));else a=R.arrayBufferToString(o);if(null==a)return null;t=JSON.parse(a)}catch{}return t}async function q(e,t){var r={},o=function(e){return"_"==e[0]&&"$"+e.substring(1)};for(var n in e){var a=o(n);r[a||n]=a?await this.encrypt(e[n]):K.clone(e[n])}return r}async function z(e,t){var r={},o=function(e){return"$"==e[0]&&"_"+e.substring(1)};for(var n in e){var a=o(n);r[a||n]=a?await this.decrypt(e[n]):K.clone(e[n])}return r}return _(),["user","state","deviceId","sessionId","version"].forEach((function(e){Object.defineProperty(N,e,{get:function(){return I[e]}})})),["tkn"].forEach((function(e){Object.defineProperty(N,e,{get:function(){return j[e]}})})),N.signup=async function(e,t,r){var o=await M(e,t),n={email:e};return n.ekeys={ePrvKey:o.ePrvKey,ePubKey:o.ePubKey,cRecKey:o.cRecKey,eRec:o.eRec,eShrKey:o.eShrKey},I.user=K.frozenClone(n),N.signin(e,t)},N.signin=async function(e,t){if(H.signinLock)return{error:"lock"};if(H.signinLock=!0,I.user){if(I.user.email!=e)return await K.sleep(200),H.signinLock=!1,{error:"email"};D("unlocking");var r=await async function(e,t){if(!e||!e.ekeys)return!1;try{var r=e.ekeys,o={};return o.iPrvKey=await R.decryptPrivateKey(r.ePrvKey,t,{name:"RSA-OAEP",hash:"SHA-512",usages:["decrypt","unwrapKey"],isExtractable:!1}),o.iPubKey=await R.pemPublicToCrypto(r.ePubKey,{name:"RSA-OAEP",hash:"SHA-512",usages:["encrypt","wrapKey"],isExtractable:!1}),o.iShrKey=await R.decryptKey(o.iPrvKey,r.eShrKey,{type:"raw",name:"AES-GCM",length:256,usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!1}),o}catch(e){console.error(e)}return!1}(I.user,t);if(!r)return await K.sleep(200),D("locked"),H.signinLock=!1,{error:"password"};for(var o in j)delete j[o];for(var o in j.ready=!0,r)j[o]=r[o];return D("unlocked"),H.signinLock=!1,I.user}return await K.sleep(200),H.signinLock=!1,{error:"user"}},N.logout=async function(){return"unlocked"==I.state&&(D("uninitialized"),_(),!0)},N.generateEncryptedKey=async function(){if(!j.ready)return!1;var e=await R.getSharedKey(256,{cipher:"AES-GCM",usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!0});return await R.encryptKey(j.iPubKey,e)},N.create=async function(e){var t=!1;try{e.ekey?t=await async function(e,t){if(!j.ready)return!1;try{return await R.decryptKey(j.iPrvKey,e,{type:"raw",name:"AES-GCM",length:256,usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!1})}catch(e){}return!1}(e.ekey):e.key&&(t=await R.base64ToCrypto(e.key,{name:"AES-GCM",length:256,usages:["encrypt","decrypt","wrapKey","unwrapKey"],isExtractable:!1}))}catch{return!1}if(!t)return!1;var r={_key:t};return r.encrypt=V.bind(r),r.decrypt=Y.bind(r),r.encryptProps=q.bind(r),r.decryptProps=z.bind(r),r.encryptRaw=F.bind(r),r.decryptRaw=Q.bind(r),{encrypt:r.encrypt,decrypt:r.decrypt,encryptProps:r.encryptProps,decryptProps:r.decryptProps,encryptRaw:r.encryptRaw,decryptRaw:r.decryptRaw}},N}();
//# sourceMappingURL=senclave.min.js.map
