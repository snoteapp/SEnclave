{"version":3,"file":"senclave.min.js","sources":["../node_modules/lz-string/libs/lz-string.js","../node_modules/opencrypto/src/OpenCrypto.js","../src/utils.js","../src/senclave.js"],"sourcesContent":["// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.5\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (typeof define === 'function' && define.amd) {\n  define(function () { return LZString; });\n} else if( typeof module !== 'undefined' && module != null ) {\n  module.exports = LZString\n} else if( typeof angular !== 'undefined' && angular != null ) {\n  angular.module('LZString', [])\n  .factory('LZString', function () {\n    return LZString;\n  });\n}\n","/**\n *\n * Copyright (c) 2016 SafeBash\n * Cryptography consultant: Andrew Kozlik, Ph.D.\n *\n */\n\n/**\n * MIT License\n *\n * Copyright (c) 2016 SafeBash\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst cryptoLib = window.crypto || window.msCrypto\nconst cryptoApi = cryptoLib.subtle || cryptoLib.webkitSubtle\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nconst lookup = new Uint8Array(256)\n\nconst PBES2_OID = '06092a864886f70d01050d'\nconst PBKDF2_OID = '06092a864886f70d01050c'\n\nconst AES256GCM_OID = '060960864801650304012e'\nconst AES192GCM_OID = '060960864801650304011a'\nconst AES128GCM_OID = '0609608648016503040106'\n\nconst AES256CBC_OID = '060960864801650304012a'\nconst AES192CBC_OID = '0609608648016503040116'\nconst AES128CBC_OID = '0609608648016503040102'\n\nconst AES256CFB_OID = '060960864801650304012c'\nconst AES192CFB_OID = '0609608648016503040118'\nconst AES128CFB_OID = '06086086480165030404'\n\nconst SHA512_OID = '06082a864886f70d020b0500'\nconst SHA384_OID = '06082a864886f70d020a0500'\nconst SHA256_OID = '06082a864886f70d02090500'\nconst SHA1_OID = '06082a864886f70d02070500'\n\nconst RSA_OID = '06092a864886f70d010101'\nconst EC_OID = '06072a8648ce3d0201'\nconst P256_OID = '06082a8648ce3d030107'\nconst P384_OID = '06052b81040022'\nconst P521_OID = '06052b81040023'\n\nexport default class OpenCrypto {\n  constructor () {\n    for (let i = 0; i < chars.length; i++) {\n      lookup[chars.charCodeAt(i)] = i\n    }\n  }\n\n  /**\n   * BEGIN\n   * base64-arraybuffer\n   * GitHub @niklasvh\n   * Copyright (c) 2012 Niklas von Hertzen\n   * MIT License\n   */\n  encodeAb (arrayBuffer) {\n    const bytes = new Uint8Array(arrayBuffer)\n    const len = bytes.length\n    let base64 = ''\n\n    for (let i = 0; i < len; i += 3) {\n      base64 += chars[bytes[i] >> 2]\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)]\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)]\n      base64 += chars[bytes[i + 2] & 63]\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + '='\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + '=='\n    }\n\n    return base64\n  }\n\n  decodeAb (base64) {\n    const len = base64.length\n    let bufferLength = base64.length * 0.75\n    let p = 0\n    let encoded1\n    let encoded2\n    let encoded3\n    let encoded4\n\n    if (base64[base64.length - 1] === '=') {\n      bufferLength--\n      if (base64[base64.length - 2] === '=') {\n        bufferLength--\n      }\n    }\n\n    const arrayBuffer = new ArrayBuffer(bufferLength)\n    let bytes = new Uint8Array(arrayBuffer)\n\n    for (let i = 0; i < len; i += 4) {\n      encoded1 = lookup[base64.charCodeAt(i)]\n      encoded2 = lookup[base64.charCodeAt(i + 1)]\n      encoded3 = lookup[base64.charCodeAt(i + 2)]\n      encoded4 = lookup[base64.charCodeAt(i + 3)]\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4)\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2)\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63)\n    }\n\n    return arrayBuffer\n  }\n  /**\n   * END\n   * base64-arraybuffer\n   */\n\n  /**\n   * Method for encoding ArrayBuffer into UTF-8 String\n   */\n  arrayBufferToString (arrayBuffer) {\n    if (typeof arrayBuffer !== 'object') {\n      throw new TypeError('Expected input of arrayBuffer to be an ArrayBuffer Object')\n    }\n\n    const decoder = new TextDecoder('utf-8')\n    return decoder.decode(arrayBuffer)\n  }\n\n  /**\n   * Method for decoding String to ArrayBuffer\n   */\n  stringToArrayBuffer (str) {\n    if (typeof str !== 'string') {\n      throw new TypeError('Expected input of str to be a String')\n    }\n\n    const encoder = new TextEncoder('utf-8')\n    const byteArray = encoder.encode(str)\n    return byteArray.buffer\n  }\n\n  /**\n   * Method for encoding ArrayBuffer to hexadecimal String\n   */\n  arrayBufferToHexString (arrayBuffer) {\n    if (typeof arrayBuffer !== 'object') {\n      throw new TypeError('Expected input of arrayBuffer to be an ArrayBuffer Object')\n    }\n\n    const byteArray = new Uint8Array(arrayBuffer)\n    let hexString = ''\n    let nextHexByte\n\n    for (let i = 0; i < byteArray.byteLength; i++) {\n      nextHexByte = byteArray[i].toString(16)\n\n      if (nextHexByte.length < 2) {\n        nextHexByte = '0' + nextHexByte\n      }\n\n      hexString += nextHexByte\n    }\n\n    return hexString\n  }\n\n  /**\n   * Method for decoding hexadecimal String to ArrayBuffer\n   */\n  hexStringToArrayBuffer (hexString) {\n    if (typeof hexString !== 'string') {\n      throw new TypeError('Expected input of hexString to be a String')\n    }\n\n    if ((hexString.length % 2) !== 0) {\n      throw new RangeError('Expected string to be an even number of characters')\n    }\n\n    const byteArray = new Uint8Array(hexString.length / 2)\n    for (let i = 0; i < hexString.length; i += 2) {\n      byteArray[i / 2] = parseInt(hexString.substring(i, i + 2), 16)\n    }\n\n    return byteArray.buffer\n  }\n\n  /**\n   * Method for encoding ArrayBuffer to base64 String\n   */\n  arrayBufferToBase64 (arrayBuffer) {\n    if (typeof arrayBuffer !== 'object') {\n      throw new TypeError('Expected input of arrayBuffer to be an ArrayBuffer Object')\n    }\n\n    return this.encodeAb(arrayBuffer)\n  }\n\n  /**\n   * Method for decoding base64 String to ArrayBuffer\n   */\n  base64ToArrayBuffer (b64) {\n    if (typeof b64 !== 'string') {\n      throw new TypeError('Expected input of b64 to be a Base64 String')\n    }\n\n    return this.decodeAb(b64)\n  }\n\n  /**\n   * Method for encoding decimal Number to hexadecimal String\n   */\n  decimalToHex (d, unsigned) {\n    unsigned = (typeof unsigned !== 'undefined') ? unsigned : false\n\n    if (typeof unsigned !== 'boolean') {\n      throw new TypeError('Expected input of unsigned to be a Boolean')\n    }\n\n    let h = null\n    if (typeof d === 'number') {\n      if (unsigned) {\n        h = (d).toString(16)\n        return h.length % 2 ? '000' + h : '00' + h\n      } else {\n        h = (d).toString(16)\n        return h.length % 2 ? '0' + h : h\n      }\n    } else if (typeof d === 'string') {\n      h = (d.length / 2).toString(16)\n      return h.length % 2 ? '0' + h : h\n    } else {\n      throw new TypeError('Expected input of d to be a Number or String')\n    }\n  }\n\n  /**\n   * Method for addition of new lines into PEM encoded key\n   */\n  addNewLines (str) {\n    let finalString = ''\n    while (str.length > 0) {\n      finalString += str.substring(0, 64) + '\\r\\n'\n      str = str.substring(64)\n    }\n\n    return finalString\n  }\n\n  /**\n   * Method that removes lines from PEM encoded key\n   */\n  removeLines (str) {\n    return str.replace(/\\r?\\n|\\r/g, '')\n  }\n\n  /**\n   * Method that encodes ASN.1 information into PEM encoded key\n   */\n  toAsn1 (wrappedKey, salt, iv, iterations, hash, cipher, length) {\n    wrappedKey = this.arrayBufferToHexString(wrappedKey)\n    salt = this.arrayBufferToHexString(salt)\n    iv = this.arrayBufferToHexString(iv)\n    iterations = this.decimalToHex(iterations, true)\n\n    const opt = {}\n\n    switch (hash) {\n      case 'SHA-512' :\n        opt.HASH_OID = SHA512_OID\n        break\n      case 'SHA-384' :\n        opt.HASH_OID = SHA384_OID\n        break\n      case 'SHA-256' :\n        opt.HASH_OID = SHA256_OID\n        break\n      case 'SHA-1' :\n        opt.HASH_OID = SHA1_OID\n    }\n\n    switch (cipher) {\n      case 'AES-GCM' :\n        if (length === 256) {\n          opt.CIPHER_OID = AES256GCM_OID\n        } else if (length === 192) {\n          opt.CIPHER_OID = AES192GCM_OID\n        } else if (length === 128) {\n          opt.CIPHER_OID = AES128GCM_OID\n        }\n        break\n      case 'AES-CBC' :\n        if (length === 256) {\n          opt.CIPHER_OID = AES256CBC_OID\n        } else if (length === 192) {\n          opt.CIPHER_OID = AES192CBC_OID\n        } else if (length === 128) {\n          opt.CIPHER_OID = AES128CBC_OID\n        }\n        break\n      case 'AES-CFB' :\n        if (length === 256) {\n          opt.CIPHER_OID = AES256CFB_OID\n        } else if (length === 192) {\n          opt.CIPHER_OID = AES192CFB_OID\n        } else if (length === 128) {\n          opt.CIPHER_OID = AES128CFB_OID\n        }\n    }\n\n    const ITER_INTEGER = '02' + this.decimalToHex(iterations.length / 2) + iterations\n    const SALT_OCTET = '04' + this.decimalToHex(salt) + salt\n    const IV_OCTET = '04' + this.decimalToHex(iv) + iv\n    const KEY_OCTET_PADDING = this.decimalToHex(wrappedKey).length / 2 === 2 ? '82' : '81'\n    const KEY_OCTET = '04' + KEY_OCTET_PADDING + this.decimalToHex(wrappedKey) + wrappedKey\n\n    opt.SEQUENCE_AES_CONTAINER = '30' + this.decimalToHex(opt.CIPHER_OID + IV_OCTET)\n    opt.SEQUENCE_HASH_CONTAINER = '30' + this.decimalToHex(opt.HASH_OID)\n    opt.SEQUENCE_PBKDF2_INNER_CONTAINER = '30' + this.decimalToHex(SALT_OCTET + ITER_INTEGER + opt.SEQUENCE_HASH_CONTAINER + opt.HASH_OID)\n    opt.SEQUENCE_PBKDF2_CONTAINER = '30' + this.decimalToHex(PBKDF2_OID + opt.SEQUENCE_PBKDF2_INNER_CONTAINER + SALT_OCTET + ITER_INTEGER + opt.SEQUENCE_HASH_CONTAINER + opt.HASH_OID)\n    opt.SEQUENCE_PBES2_INNER_CONTAINER = '30' + this.decimalToHex(opt.SEQUENCE_PBKDF2_CONTAINER + PBKDF2_OID + opt.SEQUENCE_PBKDF2_INNER_CONTAINER + SALT_OCTET + ITER_INTEGER + opt.SEQUENCE_HASH_CONTAINER + opt.HASH_OID + opt.SEQUENCE_AES_CONTAINER + opt.CIPHER_OID + IV_OCTET)\n    opt.SEQUENCE_PBES2_CONTAINER = '30' + this.decimalToHex(PBES2_OID + opt.SEQUENCE_PBES2_INNER_CONTAINER + opt.SEQUENCE_PBKDF2_CONTAINER + PBKDF2_OID + opt.SEQUENCE_PBKDF2_INNER_CONTAINER + SALT_OCTET + ITER_INTEGER + opt.SEQUENCE_HASH_CONTAINER + opt.HASH_OID + opt.SEQUENCE_AES_CONTAINER + opt.CIPHER_OID + IV_OCTET)\n\n    const SEQUENCE_PARAMETERS = opt.SEQUENCE_PBES2_CONTAINER + PBES2_OID + opt.SEQUENCE_PBES2_INNER_CONTAINER + opt.SEQUENCE_PBKDF2_CONTAINER + PBKDF2_OID + opt.SEQUENCE_PBKDF2_INNER_CONTAINER + SALT_OCTET + ITER_INTEGER + opt.SEQUENCE_HASH_CONTAINER + opt.HASH_OID + opt.SEQUENCE_AES_CONTAINER + opt.CIPHER_OID + IV_OCTET\n    const SEQUENCE_LENGTH = this.decimalToHex(SEQUENCE_PARAMETERS + KEY_OCTET)\n    const SEQUENCE_PADDING = SEQUENCE_LENGTH.length / 2 === 2 ? '82' : '81'\n    const SEQUENCE = '30' + SEQUENCE_PADDING + SEQUENCE_LENGTH + SEQUENCE_PARAMETERS + KEY_OCTET\n\n    const asnKey = this.hexStringToArrayBuffer(SEQUENCE)\n    let pemKey = this.arrayBufferToBase64(asnKey)\n    pemKey = this.addNewLines(pemKey)\n    pemKey = '-----BEGIN ENCRYPTED PRIVATE KEY-----\\r\\n' + pemKey + '-----END ENCRYPTED PRIVATE KEY-----'\n\n    return pemKey\n  }\n\n  /**\n   * Method that retrieves ASN.1 encoded information from PEM encoded key\n   */\n  fromAsn1 (pem) {\n    pem = this.removeLines(pem)\n    pem = pem.replace('-----BEGIN ENCRYPTED PRIVATE KEY-----', '')\n    pem = pem.replace('-----END ENCRYPTED PRIVATE KEY-----', '')\n    pem = this.base64ToArrayBuffer(pem)\n\n    const opt = {}\n    const hex = this.arrayBufferToHexString(pem)\n    opt.data = hex\n\n    if (opt.data.includes(PBES2_OID) && opt.data.includes(PBKDF2_OID)) {\n      opt.valid = true\n    }\n\n    opt.saltBegin = opt.data.indexOf(PBKDF2_OID) + 28\n\n    if (opt.data.includes(AES256GCM_OID)) {\n      opt.cipher = 'AES-GCM'\n      opt.length = 256\n      opt.ivBegin = opt.data.indexOf(AES256GCM_OID) + 24\n    } else if (opt.data.includes(AES192GCM_OID)) {\n      opt.cipher = 'AES-GCM'\n      opt.length = 192\n      opt.ivBegin = opt.data.indexOf(AES192GCM_OID) + 24\n    } else if (opt.data.includes(AES128GCM_OID)) {\n      opt.cipher = 'AES-GCM'\n      opt.length = 128\n      opt.ivBegin = opt.data.indexOf(AES128GCM_OID) + 24\n    } else if (opt.data.includes(AES256CBC_OID)) {\n      opt.cipher = 'AES-CBC'\n      opt.length = 256\n      opt.ivBegin = opt.data.indexOf(AES256CBC_OID) + 24\n    } else if (opt.data.includes(AES192CBC_OID)) {\n      opt.cipher = 'AES-CBC'\n      opt.length = 192\n      opt.ivBegin = opt.data.indexOf(AES192CBC_OID) + 24\n    } else if (opt.data.includes(AES128CBC_OID)) {\n      opt.cipher = 'AES-CBC'\n      opt.length = 128\n      opt.ivBegin = opt.data.indexOf(AES128CBC_OID) + 24\n    } else if (opt.data.includes(AES256CFB_OID)) {\n      opt.cipher = 'AES-CFB'\n      opt.length = 256\n      opt.ivBegin = opt.data.indexOf(AES256CFB_OID) + 24\n    } else if (opt.data.includes(AES192CFB_OID)) {\n      opt.cipher = 'AES-CFB'\n      opt.length = 192\n      opt.ivBegin = opt.data.indexOf(AES192CFB_OID) + 24\n    } else if (opt.data.includes(AES128CFB_OID)) {\n      opt.cipher = 'AES-CFB'\n      opt.length = 128\n      opt.ivBegin = opt.data.indexOf(AES128CFB_OID) + 22\n    }\n\n    if (opt.data.includes(SHA512_OID)) {\n      opt.hash = 'SHA-512'\n    } else if (opt.data.includes(SHA384_OID)) {\n      opt.hash = 'SHA-384'\n    } else if (opt.data.includes(SHA256_OID)) {\n      opt.hash = 'SHA-256'\n    } else if (opt.data.includes(SHA1_OID)) {\n      opt.hash = 'SHA-1'\n    }\n\n    opt.saltLength = parseInt(opt.data.substr(opt.saltBegin, 2), 16)\n    opt.ivLength = parseInt(opt.data.substr(opt.ivBegin, 2), 16)\n\n    opt.salt = opt.data.substr(opt.saltBegin + 2, opt.saltLength * 2)\n    opt.iv = opt.data.substr(opt.ivBegin + 2, opt.ivLength * 2)\n\n    opt.iterBegin = opt.saltBegin + 4 + (opt.saltLength * 2)\n    opt.iterLength = parseInt(opt.data.substr(opt.iterBegin, 2), 16)\n    opt.iter = parseInt(opt.data.substr(opt.iterBegin + 2, opt.iterLength * 2), 16)\n\n    opt.sequencePadding = opt.data.substr(2, 2) === '81' ? 8 : 10\n    opt.parametersPadding = opt.data.substr(2, 2) === '81' ? 12 : 16\n    opt.sequenceLength = parseInt(opt.data.substr(opt.sequencePadding, 2), 16)\n    opt.encryptedDataBegin = opt.parametersPadding + (opt.sequenceLength * 2)\n    opt.encryptedDataPadding = opt.data.substr(opt.encryptedDataBegin - 2, 2) === '81' ? 2 : 4\n    opt.encryptedDataLength = parseInt(opt.data.substr(opt.encryptedDataBegin, 6), 16)\n    opt.encryptedData = opt.data.substr(opt.encryptedDataBegin + opt.encryptedDataPadding, (opt.encryptedDataLength * 2))\n\n    const res = {\n      salt: this.hexStringToArrayBuffer(opt.salt),\n      iv: this.hexStringToArrayBuffer(opt.iv),\n      cipher: opt.cipher,\n      length: opt.length,\n      hash: opt.hash,\n      iter: opt.iter,\n      encryptedData: this.hexStringToArrayBuffer(opt.encryptedData)\n    }\n\n    return res\n  }\n\n  /**\n   * Method that converts asymmetric private key from CryptoKey to PEM format\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   */\n  cryptoPrivateToPem (privateKey) {\n    const self = this\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input to be a CryptoKey Object')\n      }\n\n      cryptoApi.exportKey(\n        'pkcs8',\n        privateKey\n      ).then(exportedPrivateKey => {\n        const b64 = self.arrayBufferToBase64(exportedPrivateKey)\n        let pem = self.addNewLines(b64)\n        pem = '-----BEGIN PRIVATE KEY-----\\r\\n' + pem + '-----END PRIVATE KEY-----'\n\n        resolve(pem)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that converts asymmetric private key from PEM to CryptoKey format\n   * @param {String} pem default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDH: { name: 'ECDH', usages: ['deriveKey', 'deriveBits'], isExtractable: true }\n   * -- ECDSA: { name: 'ECDSA', usages: ['sign'], isExtractable: true }\n   * -- RSA-OAEP: { name: 'RSA-OAEP', hash: { name: 'SHA-512' }, usages: ['decrypt', 'unwrapKey'], isExtractable: true }\n   * -- RSA-PSS: { name: 'RSA-PSS', hash: { name: 'SHA-512' }, usages: ['sign'], isExtractable: true }\n   */\n  pemPrivateToCrypto (pem, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof pem !== 'string') {\n        throw new TypeError('Expected input of pem to be a String')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      pem = pem.replace('-----BEGIN PRIVATE KEY-----', '')\n      pem = pem.replace('-----END PRIVATE KEY-----', '')\n\n      const b64 = self.removeLines(pem)\n      const arrayBuffer = self.base64ToArrayBuffer(b64)\n      const hex = self.arrayBufferToHexString(arrayBuffer)\n      const keyOptions = {}\n\n      if (hex.includes(EC_OID)) {\n        options.name = (typeof options.name !== 'undefined') ? options.name : 'ECDH'\n\n        if (typeof options.name !== 'string') {\n          throw new TypeError('Expected input of options.name to be a String')\n        }\n\n        let curve = null\n        if (hex.includes(P256_OID)) {\n          curve = 'P-256'\n        } else if (hex.includes(P384_OID)) {\n          curve = 'P-384'\n        } else if (hex.includes(P521_OID)) {\n          curve = 'P-521'\n        }\n\n        if (options.name === 'ECDH') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['deriveKey', 'deriveBits']\n        } else if (options.name === 'ECDSA') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n        } else {\n          throw new TypeError('Expected input of options.name is not a valid algorithm name')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.name = options.name\n        keyOptions.namedCurve = curve\n      } else if (hex.includes(RSA_OID)) {\n        options.name = (typeof options.name !== 'undefined') ? options.name : 'RSA-OAEP'\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n\n        if (typeof options.name !== 'string') {\n          throw new TypeError('Expected input of options.name to be a String')\n        }\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        if (options.name === 'RSA-OAEP') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['decrypt', 'unwrapKey']\n        } else if (options.name === 'RSA-PSS') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n        } else {\n          throw new TypeError('Expected input of options.name is not a valid algorithm name')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.name = options.name\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else {\n        throw new TypeError('Expected input of pem is not a valid private key')\n      }\n\n      cryptoApi.importKey(\n        'pkcs8',\n        arrayBuffer,\n        keyOptions,\n        options.isExtractable,\n        options.usages\n      ).then(importedPrivateKey => {\n        resolve(importedPrivateKey)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that converts asymmetric public key from CryptoKey to PEM format\n   * @param {CryptoKey} publicKey default: \"undefined\"\n   */\n  cryptoPublicToPem (publicKey) {\n    const self = this\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(publicKey) !== '[object CryptoKey]' && publicKey.type !== 'public') {\n        throw new TypeError('Expected input of publicKey to be a CryptoKey Object of type public')\n      }\n\n      cryptoApi.exportKey(\n        'spki',\n        publicKey\n      ).then(exportedPublicKey => {\n        const b64 = self.arrayBufferToBase64(exportedPublicKey)\n        let pem = self.addNewLines(b64)\n        pem = '-----BEGIN PUBLIC KEY-----\\r\\n' + pem + '-----END PUBLIC KEY-----'\n\n        resolve(pem)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that converts asymmetric public key from PEM to CryptoKey format\n   * @param {String} publicKey default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDH: { name: 'ECDH', usages: [], isExtractable: true }\n   * -- ECDSA: { name: 'ECDSA', usages: ['verify'], isExtractable: true }\n   * -- RSA-OAEP: { name: 'RSA-OAEP', hash: { name: 'SHA-512' }, usages: ['encrypt', 'wrapKey'], isExtractable: true }\n   * -- RSA-PSS: { name: 'RSA-PSS', hash: { name: 'SHA-512' }, usages: ['verify'], isExtractable: true }\n   */\n  pemPublicToCrypto (pem, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof pem !== 'string') {\n        throw new TypeError('Expected input of pem to be a String')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      pem = pem.replace('-----BEGIN PUBLIC KEY-----', '')\n      pem = pem.replace('-----END PUBLIC KEY-----', '')\n\n      const b64 = self.removeLines(pem)\n      const arrayBuffer = self.base64ToArrayBuffer(b64)\n      const hex = self.arrayBufferToHexString(arrayBuffer)\n      const keyOptions = {}\n\n      if (hex.includes(EC_OID)) {\n        options.name = (typeof options.name !== 'undefined') ? options.name : 'ECDH'\n\n        if (typeof options.name !== 'string') {\n          throw new TypeError('Expected input of options.name to be a String')\n        }\n\n        let curve = null\n        if (hex.includes(P256_OID)) {\n          curve = 'P-256'\n        } else if (hex.includes(P384_OID)) {\n          curve = 'P-384'\n        } else if (hex.includes(P521_OID)) {\n          curve = 'P-521'\n        }\n\n        if (options.name === 'ECDH') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : []\n        } else if (options.name === 'ECDSA') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['verify']\n        } else {\n          throw new TypeError('Expected input of options.name is not a valid algorithm name')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.name = options.name\n        keyOptions.namedCurve = curve\n      } else if (hex.includes(RSA_OID)) {\n        options.name = (typeof options.name !== 'undefined') ? options.name : 'RSA-OAEP'\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n\n        if (typeof options.name !== 'string') {\n          throw new TypeError('Expected input of options.name to be a String')\n        }\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        if (options.name === 'RSA-OAEP') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'wrapKey']\n        } else if (options.name === 'RSA-PSS') {\n          options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['verify']\n        } else {\n          throw new TypeError('Expected input of options.name is not a valid algorithm name')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.name = options.name\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else {\n        throw new TypeError('Expected input of pem is not a valid public key')\n      }\n\n      cryptoApi.importKey(\n        'spki',\n        arrayBuffer,\n        keyOptions,\n        options.isExtractable,\n        options.usages\n      ).then(importedPublicKey => {\n        resolve(importedPublicKey)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that converts CryptoKey to base64\n   * @param {CryptoKey} key default: \"undefined\"\n   * @param {String} type default: \"secret: 'raw'; private: 'pkcs8'; public: 'spki'\"\n   */\n  cryptoToBase64 (key, type) {\n    const self = this\n\n    let keyType = null\n    switch (key.type) {\n      case 'secret' :\n        keyType = 'raw'\n        break\n      case 'private' :\n        keyType = 'pkcs8'\n        break\n      case 'public' :\n        keyType = 'spki'\n    }\n\n    type = (typeof type !== 'undefined') ? type : keyType\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(key) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of key to be a CryptoKey Object')\n      }\n\n      if (typeof type !== 'string') {\n        throw new TypeError('Expected input of type to be a String')\n      }\n\n      cryptoApi.exportKey(\n        keyType,\n        key\n      ).then(exportedKey => {\n        const b64Key = self.arrayBufferToBase64(exportedKey)\n        resolve(b64Key)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that converts base64 encoded key to CryptoKey\n   * @param {String} key default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- AES-GCM: { name: 'AES-GCM', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- AES-CBC: { name: 'AES-CBC', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- ECDH: { name: 'ECDH', namedCurve: 'P-256', usages: ['deriveKey', 'deriveBits'], isExtractable: true }\n   * -- ECDSA: { name: 'ECDSA', namedCurve: 'P-256', usages: ['sign', 'verify'], isExtractable: true }\n   * -- RSA-OAEP: { name: 'RSA-OAEP', hash: { name: 'SHA-512' }, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- RSA-PSS: { name: 'RSA-PSS', hash: { name: 'SHA-512' }, usages: ['sign', 'verify'], isExtractable: true }\n   */\n  base64ToCrypto (key, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.name = (typeof options.name !== 'undefined') ? options.name : 'AES-GCM'\n    options.isExtractable = (typeof options.isExtractable !== 'undefined' ) ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof key !== 'string') {\n        throw new TypeError('Expected input of key to be a Base64 String')\n      }\n\n      if (typeof options.name !== 'string') {\n        throw new TypeError('Expected input of options.name to be a String')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      const keyOptions = {}\n      keyOptions.name = options.name\n\n      if (options.name === 'AES-GCM' || options.name === 'AES-CBC') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'raw'\n        options.length = (typeof options.length !== 'undefined') ? options.length : 256\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n\n        if (typeof options.length !== 'number') {\n          throw new TypeError('Expected input of options.length to be a Number')\n        }\n      } else if (options.name === 'ECDH') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.namedCurve = (typeof options.namedCurve !== 'undefined') ? options.namedCurve : 'P-256'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['deriveKey', 'deriveBits']\n\n        if (typeof options.namedCurve !== 'string') {\n          throw new TypeError('Expected input of options.namedCurve to be a String')\n        }\n\n        keyOptions.namedCurve = options.namedCurve\n      } else if (options.name === 'ECDSA') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.namedCurve = (typeof options.namedCurve !== 'undefined') ? options.namedCurve : 'P-256'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n\n        if (typeof options.namedCurve !== 'string') {\n          throw new TypeError('Expected input of options.namedCurve to be a String')\n        }\n\n        keyOptions.namedCurve = options.namedCurve\n      } else if (options.name === 'RSA-OAEP') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['decrypt', 'unwrapKey']\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else if (options.name === 'RSA-PSS') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else {\n        throw new TypeError('Expected input of options.name is not a valid algorithm name')\n      }\n\n      if (typeof options.type !== 'string') {\n        throw new TypeError('Expected input of options.type to be a String')\n      }\n\n      if (typeof options.usages !== 'object') {\n        throw new TypeError('Expected input of options.usages to be an Array')\n      }\n\n      const abKey = self.base64ToArrayBuffer(key)\n\n      cryptoApi.importKey(\n        options.type,\n        abKey,\n        keyOptions,\n        options.isExtractable,\n        options.usages\n      ).then(importedKey => {\n        resolve(importedKey)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that generates asymmetric RSA-OAEP key pair\n   * @param {Integer} modulusLength default: \"2048\"\n   * @param {String} hash default: \"SHA-512\"\n   * @param {String} paddingScheme default: \"RSA-OAEP\"\n   * @param {Array} usages default: \"['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\"\n   * @param {Boolean} isExtractable default: \"true\"\n   */\n  getRSAKeyPair (modulusLength, hash, paddingScheme, usages, isExtractable) {\n    modulusLength = (typeof modulusLength !== 'undefined') ? modulusLength : 2048\n    hash = (typeof hash !== 'undefined') ? hash : 'SHA-512'\n    paddingScheme = (typeof paddingScheme !== 'undefined') ? paddingScheme : 'RSA-OAEP'\n    isExtractable = (typeof isExtractable !== 'undefined') ? isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof modulusLength !== 'number') {\n        throw new TypeError('Expected input of modulusLength to be a Number')\n      }\n\n      if (typeof hash !== 'string') {\n        throw new TypeError('Expected input of hash expected to be a String')\n      }\n\n      if (typeof paddingScheme !== 'string') {\n        throw new TypeError('Expected input of paddingScheme to be a String')\n      }\n\n      if (typeof isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of isExtractable to be a Boolean')\n      }\n\n      if (paddingScheme === 'RSA-OAEP') {\n        usages = (typeof usages !== 'undefined') ? usages : ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n      } else if (paddingScheme === 'RSA-PSS') {\n        usages = (typeof usages !== 'undefined') ? usages : ['sign', 'verify']\n      } else {\n        throw new TypeError('Expected input of paddingScheme is not a valid padding scheme')\n      }\n\n      if (typeof usages !== 'object') {\n        throw new TypeError('Expected input of usages to be an Array')\n      }\n\n      cryptoApi.generateKey(\n        {\n          name: paddingScheme,\n          modulusLength: modulusLength,\n          publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n          hash: { name: hash }\n        },\n        isExtractable,\n        usages\n      ).then(keyPair => {\n        resolve(keyPair)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that encrypts data using asymmetric encryption\n   * @param {CryptoKey} publicKey default: \"undefined\"\n   * @param {ArrayBuffer} data default: \"undefined\"\n   */\n  rsaEncrypt (publicKey, data) {\n    const self = this\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(publicKey) !== '[object CryptoKey]' && publicKey.type !== 'public') {\n        throw new TypeError('Expected input of publicKey to be a CryptoKey Object of type public')\n      }\n\n      if (typeof data !== 'object') {\n        throw new TypeError('Expected input of data to be an ArrayBuffer')\n      }\n\n      cryptoApi.encrypt(\n        {\n          name: 'RSA-OAEP'\n        },\n        publicKey,\n        data\n      ).then(encryptedDataAb => {\n        const encryptedDataB64 = self.arrayBufferToBase64(encryptedDataAb)\n        resolve(encryptedDataB64)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that decrypts data using asymmetric encryption\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   * @param {String} encryptedData default: \"undefined\"\n   */\n  rsaDecrypt (privateKey, encryptedData) {\n    const self = this\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input of privateKey to be a CryptoKey Object of type private')\n      }\n\n      if (typeof encryptedData !== 'string') {\n        throw new TypeError('Expected input of encryptedData to be a Base64 String')\n      }\n\n      const encryptedDataAb = self.base64ToArrayBuffer(encryptedData)\n\n      cryptoApi.decrypt(\n        {\n          name: 'RSA-OAEP'\n        },\n        privateKey,\n        encryptedDataAb\n      ).then(decryptedDataAb => {\n        resolve(decryptedDataAb)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that generates asymmetric Elliptic Curve Diffie-Hellman key pair\n   * @param {String} curve default: \"P-256\"\n   * @param {String} type default: \"ECDH\"\n   * @param {Array} usages default: \"['deriveKey', 'deriveBits']\"\n   * @param {Boolean} isExtractable default: \"true\"\n   */\n  getECKeyPair (curve, type, usages, isExtractable) {\n    curve = (typeof curve !== 'undefined') ? curve : 'P-256'\n    type = (typeof type !== 'undefined') ? type : 'ECDH'\n    isExtractable = (typeof isExtractable !== 'undefined') ? isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof curve !== 'string') {\n        throw new TypeError('Expected input of curve to be a String')\n      }\n\n      if (typeof type !== 'string') {\n        throw new TypeError('Expected input of type to be a String')\n      }\n\n      if (typeof isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of isExtractable to be a Boolean')\n      }\n\n      if (type === 'ECDH') {\n        usages = (typeof usages !== 'undefined') ? usages : ['deriveKey', 'deriveBits']\n      } else if (type === 'ECDSA') {\n        usages = (typeof usages !== 'undefined') ? usages : ['sign', 'verify']\n      } else {\n        throw new TypeError('Expected input of type is not a valid algorithm type')\n      }\n\n      if (typeof usages !== 'object') {\n        throw new TypeError('Expected input of usages to be an Array')\n      }\n\n      cryptoApi.generateKey(\n        {\n          name: type,\n          namedCurve: curve\n        },\n        isExtractable,\n        usages\n      ).then(keyPair => {\n        resolve(keyPair)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that retrieves public key from private key\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDH: { usages: ['deriveKey', 'deriveBits'], isExtractable: true }\n   * -- ECDSA: { usages: ['sign', 'verify'], isExtractable: true }\n   * -- RSA-OAEP: { usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- RSA-PSS: { usages: ['sign', 'verify'], isExtractable: true }\n   */\n  getPublicKey (privateKey, options) {\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input of privateKey must be a CryptoKey Object of type private')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      cryptoApi.exportKey('jwk', privateKey).then(jwkKey => {\n        const keyOptions = {}\n        keyOptions.name = privateKey.algorithm.name\n\n        switch (privateKey.algorithm.name) {\n          case 'ECDH' :\n            delete jwkKey.d\n            jwkKey.key_ops = []\n\n            options.usages = (typeof options.usages !== 'undefined') ? options.usages : []\n\n            if (typeof options.usages !== 'object') {\n              throw new TypeError('Expected input of options.usages to be an Array')\n            }\n\n            keyOptions.namedCurve = privateKey.algorithm.namedCurve\n            break\n          case 'ECDSA' :\n            delete jwkKey.d\n            jwkKey.key_ops = ['verify']\n\n            options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['verify']\n\n            if (typeof options.usages !== 'object') {\n              throw new TypeError('Expected input of options.usages to be an Array')\n            }\n\n            keyOptions.namedCurve = privateKey.algorithm.namedCurve\n            break\n          case 'RSA-OAEP' :\n            delete jwkKey.d\n            delete jwkKey.dp\n            delete jwkKey.dq\n            delete jwkKey.p\n            delete jwkKey.q\n            delete jwkKey.qi\n            jwkKey.key_ops = ['encrypt', 'wrapKey']\n\n            options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'wrapKey']\n\n            if (typeof options.usages !== 'object') {\n              throw new TypeError('Expected input of options.usages to be an Array')\n            }\n\n            keyOptions.hash = {}\n            keyOptions.hash.name = privateKey.algorithm.hash.name\n            break\n          case 'RSA-PSS' :\n            delete jwkKey.d\n            delete jwkKey.dp\n            delete jwkKey.dq\n            delete jwkKey.p\n            delete jwkKey.q\n            delete jwkKey.qi\n            jwkKey.key_ops = ['verify']\n\n            options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['verify']\n\n            if (typeof options.usages !== 'object') {\n              throw new TypeError('Expected input of options.usages to be an Array')\n            }\n\n            keyOptions.hash = {}\n            keyOptions.hash.name = privateKey.algorithm.hash.name\n            break\n          default :\n            throw new TypeError('Expected input of privateKey is not a valid private key')\n        }\n\n        cryptoApi.importKey(\n          'jwk',\n          jwkKey,\n          keyOptions,\n          options.isExtractable,\n          options.usages\n        ).then(publicKey => {\n          resolve(publicKey)\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that encrypts asymmetric private key using passphrase to enable storage in unsecure environment\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   * @param {String} passphrase default: \"undefined\"\n   * @param {Number} iterations default: \"64000\"\n   * @param {String} hash default: \"SHA-512\"\n   * @param {String} cipher default: \"AES-GCM\"\n   * @param {Number} length default: \"256\"\n   */\n  encryptPrivateKey (privateKey, passphrase, iterations, hash, cipher, length) {\n    const self = this\n\n    iterations = (typeof iterations !== 'undefined') ? iterations : 64000\n    hash = (typeof hash !== 'undefined') ? hash : 'SHA-512'\n    cipher = (typeof cipher !== 'undefined') ? cipher : 'AES-GCM'\n    length = (typeof length !== 'undefined') ? length : 256\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input of privateKey to be a CryptoKey Object of type private')\n      }\n\n      if (typeof passphrase !== 'string') {\n        throw new TypeError('Expected input of passphrase to be a String')\n      }\n\n      if (typeof iterations !== 'number') {\n        throw new TypeError('Expected input of iterations to be a Number')\n      }\n\n      if (typeof hash !== 'string') {\n        throw new TypeError('Expected input of hash to be a String')\n      }\n\n      if (typeof cipher !== 'string') {\n        throw new TypeError('Expected input of cipher to be a String')\n      }\n\n      if (typeof length !== 'number') {\n        throw new TypeError('Expected input of length to be a Number')\n      }\n\n      let ivLength = null\n      switch (cipher) {\n        case 'AES-GCM' :\n          ivLength = 12\n          break\n        case 'AES-CBC' :\n          ivLength = 16\n          break\n        case 'AES-CFB' :\n          ivLength = 16\n          break\n      }\n\n      const salt = cryptoLib.getRandomValues(new Uint8Array(16))\n      const iv = cryptoLib.getRandomValues(new Uint8Array(ivLength))\n      const passphraseAb = self.stringToArrayBuffer(passphrase)\n\n      cryptoApi.importKey(\n        'raw',\n        passphraseAb,\n        {\n          name: 'PBKDF2'\n        },\n        false,\n        ['deriveKey']\n      ).then(baseKey => {\n        cryptoApi.deriveKey(\n          {\n            name: 'PBKDF2',\n            salt: salt,\n            iterations: iterations,\n            hash: hash\n          },\n          baseKey,\n          {\n            name: cipher,\n            length: length\n          },\n          false,\n          ['wrapKey']\n        ).then(derivedKey => {\n          cryptoApi.wrapKey(\n            'pkcs8',\n            privateKey,\n            derivedKey,\n            {\n              name: cipher,\n              iv: iv,\n              tagLength: 128\n            }\n          ).then(wrappedKey => {\n            const pemKey = self.toAsn1(wrappedKey, salt, iv, iterations, hash, cipher, length)\n            resolve(pemKey)\n          }).catch(err => {\n            reject(err)\n          })\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that decrypts asymmetric private key using passphrase\n   * @param {String} encryptedPrivateKey default: \"undefined\"\n   * @param {String} passphrase default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDH: { name: 'ECDH', namedCurve: 'P-256', usages: ['deriveKey', 'deriveBits'], isExtractable: true }\n   * -- ECDSA: { name: 'ECDSA', namedCurve: 'P-256', usages: ['sign'], isExtractable: true }\n   * -- RSA-OAEP: { name: 'RSA-OAEP', hash: 'SHA-512', usages: ['decrypt', 'unwrapKey'], isExtractable: true }\n   * -- RSA-PSS: { name: 'RSA-PSS', hash: 'SHA-512', usages: ['sign'], isExtractable: true }\n   */\n  decryptPrivateKey (encryptedPrivateKey, passphrase, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.name = (typeof options.name !== 'undefined') ? options.name : 'ECDH'\n    options.isExtractable = (typeof options.isExtractable !== 'undefined' ) ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof encryptedPrivateKey !== 'string') {\n        throw new TypeError('Expected input of encryptedPrivateKey to be a Base64 String')\n      }\n\n      if (typeof passphrase !== 'string') {\n        throw new TypeError('Expected input of passphrase to be a String')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      const epki = this.fromAsn1(encryptedPrivateKey)\n      const keyOptions = {}\n      keyOptions.name = options.name\n  \n      if (options.name === 'ECDH') {\n        options.namedCurve = (typeof options.namedCurve !== 'undefined') ? options.namedCurve : 'P-256'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['deriveKey', 'deriveBits']\n\n        if (typeof options.namedCurve !== 'string') {\n          throw new TypeError('Expected input of options.namedCurve to be a String')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.namedCurve = options.namedCurve\n      } else if (options.name === 'ECDSA') {\n        options.namedCurve = (typeof options.namedCurve !== 'undefined') ? options.namedCurve : 'P-256'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n\n        if (typeof options.namedCurve !== 'string') {\n          throw new TypeError('Expected input of options.namedCurve to be a String')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.namedCurve = options.namedCurve\n      } else if (options.name === 'RSA-OAEP') {\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['decrypt', 'unwrapKey']\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else if (options.name === 'RSA-PSS') {\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        if (typeof options.usages !== 'object') {\n          throw new TypeError('Expected input of options.usages to be an Array')\n        }\n\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else {\n        throw new TypeError('Expected input of encryptedPrivateKey is not a valid encrypted private key')\n      }\n\n      const passphraseAb = self.stringToArrayBuffer(passphrase)\n\n      cryptoApi.importKey(\n        'raw',\n        passphraseAb,\n        {\n          name: 'PBKDF2'\n        },\n        false,\n        ['deriveKey']\n      ).then(baseKey => {\n        cryptoApi.deriveKey(\n          {\n            name: 'PBKDF2',\n            salt: epki.salt,\n            iterations: epki.iter,\n            hash: epki.hash\n          },\n          baseKey,\n          {\n            name: epki.cipher,\n            length: epki.length\n          },\n          false,\n          ['unwrapKey']\n        ).then(derivedKey => {\n          cryptoApi.unwrapKey(\n            'pkcs8',\n            epki.encryptedData,\n            derivedKey,\n            {\n              name: epki.cipher,\n              iv: epki.iv,\n              tagLength: 128\n            },\n            keyOptions,\n            options.isExtractable,\n            options.usages\n          ).then(unwrappedKey => {\n            resolve(unwrappedKey)\n          }).catch(err => {\n            reject(err)\n          })\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that performs ECDH key agreement\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   * @param {CryptoKey} publicKey default: \"undefined\"\n   * @param {Object} options default: \"{ bitLength: 256, hkdfHash: 'SHA-512', hkdfSalt: \"new UInt8Array()\", hkdfInfo: \"new UInt8Array()\", cipher: 'AES-GCM', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\"\n   */\n  keyAgreement (privateKey, publicKey, options) {\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.bitLength = (typeof options.bitLength !== 'undefined') ? options.bitLength : 256\n    options.hkdfHash = (typeof options.hkdfHash !== 'undefined') ? options.hkdfHash : 'SHA-512'\n    options.hkdfSalt = (typeof options.hkdfSalt !== 'undefined') ? options.hkdfSalt : new Uint8Array()\n    options.hkdfInfo = (typeof options.hkdfInfo !== 'undefined') ? options.hkdfInfo : new Uint8Array()\n    options.cipher = (typeof options.cipher !== 'undefined') ? options.cipher : 'AES-GCM'\n    options.length = (typeof options.length !== 'undefined') ? options.length : 256\n    options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'decrypt', 'unwrapKey', 'wrapKey']\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input of privateKey to be a CryptoKey Object of type private')\n      }\n\n      if (Object.prototype.toString.call(publicKey) !== '[object CryptoKey]' && publicKey.type !== 'public') {\n        throw new TypeError('Expected input of publicKey to be a CryptoKey Object of type public')\n      }\n\n      if (typeof options.bitLength !== 'number') {\n        throw new TypeError('Expected input of options.bitLength to be a Number')\n      }\n\n      if (typeof options.hkdfHash !== 'string') {\n        throw new TypeError('Expected input of options.hkdfHash to be a String')\n      }\n\n      if (typeof options.hkdfSalt !== 'object') {\n        throw new TypeError('Expected input of options.hkdfSalt to be an ArrayBuffer')\n      }\n\n      if (typeof options.hkdfInfo !== 'object') {\n        throw new TypeError('Expected input of options.hkdfInfo to be an ArrayBuffer')\n      }\n\n      if (typeof options.cipher !== 'string') {\n        throw new TypeError('Expected input of options.cipher to be a String')\n      }\n\n      if (typeof options.length !== 'number') {\n        throw new TypeError('Expected input of options.length to be a Number')\n      }\n\n      if (typeof options.usages !== 'object') {\n        throw new TypeError('Expected input of options.usages to be an Array')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      cryptoApi.deriveBits(\n        {\n          name: 'ECDH',\n          namedCurve: publicKey.algorithm.namedCurve,\n          public: publicKey\n        },\n        privateKey,\n        options.bitLength\n      ).then(derivedBits => {\n        cryptoApi.importKey(\n          'raw',\n          derivedBits,\n          {\n            name: 'HKDF'\n          },\n          false,\n          ['deriveKey']\n        ).then(derivedKey => {\n          cryptoApi.deriveKey(\n            {\n              name: 'HKDF',\n              hash: {\n                name: options.hkdfHash\n              },\n              salt: options.hkdfSalt,\n              info: options.hkdfInfo\n            },\n            derivedKey,\n            {\n              name: options.cipher,\n              length: options.length\n            },\n            options.isExtractable,\n            options.usages\n          ).then(sharedKey => {\n            resolve(sharedKey)\n          }).catch(err => {\n            reject(err)\n          })\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that generates symmetric/shared key for AES encryption\n   * @param {Integer} length default: \"256\"\n   * @param {Object} options default: \"{ cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\"\n   */\n  getSharedKey (length, options) {\n    length = (typeof length !== 'undefined') ? length : 256\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.cipher = (typeof options.cipher !== 'undefined') ? options.cipher : 'AES-GCM'\n    options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof length !== 'number') {\n        throw new TypeError('Expected input of length to be a Number')\n      }\n\n      if (typeof options.cipher !== 'string') {\n        throw new TypeError('Expected input of options.cipher expected to be a String')\n      }\n\n      if (typeof options.usages !== 'object') {\n        throw new TypeError('Expected input of options.usages to be an Array')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable expected to be a Boolean')\n      }\n\n      cryptoApi.generateKey(\n        {\n          name: options.cipher,\n          length: length\n        },\n        options.isExtractable,\n        options.usages\n      ).then(sharedKey => {\n        resolve(sharedKey)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that encrypts keys\n   * @param {CryptoKey} wrappingKey default: \"undefined\"\n   * @param {CryptoKey} key default: \"undefined\"\n   */\n  encryptKey (wrappingKey, key) {\n    const self = this\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(wrappingKey) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of wrappingKey to be a CryptoKey Object')\n      }\n\n      if (Object.prototype.toString.call(key) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of key to be a CryptoKey Object')\n      }\n\n      let keyType = null\n      switch (key.type) {\n        case 'secret' :\n          keyType = 'raw'\n          break\n        case 'private' :\n          keyType = 'pkcs8'\n          break\n        case 'public' :\n          keyType = 'spki'\n      }\n\n      if (wrappingKey.type === 'secret') {\n        let ivAb = null\n\n        if (wrappingKey.algorithm.name === 'AES-GCM') {\n          ivAb = cryptoLib.getRandomValues(new Uint8Array(12))\n        } else if (wrappingKey.algorithm.name === 'AES-CBC') {\n          ivAb = cryptoLib.getRandomValues(new Uint8Array(16))\n        } else {\n          throw new TypeError('Cipher mode of the wrappingKey is not supported')\n        }\n\n        cryptoApi.wrapKey(\n          keyType,\n          key,\n          wrappingKey,\n          {\n            name: wrappingKey.algorithm.name,\n            iv: ivAb,\n            tagLength: 128\n          }\n        ).then(wrappedKey => {\n          const encryptedKey = self.arrayBufferToBase64(ivAb) + self.arrayBufferToBase64(wrappedKey)\n          resolve(encryptedKey)\n        }).catch(err => {\n          reject(err)\n        })\n      } else if (wrappingKey.algorithm.name === 'RSA-OAEP') {\n        if (wrappingKey.type !== 'public') {\n          throw new TypeError('Expected input of wrappingKey to be a CryptoKey Object of type public')\n        }\n\n        cryptoApi.wrapKey(\n          keyType,\n          key,\n          wrappingKey,\n          {\n            name: 'RSA-OAEP',\n            hash: { name: wrappingKey.algorithm.hash.name }\n          }\n        ).then(wrappedKey => {\n          const encryptedKey = self.arrayBufferToBase64(wrappedKey)\n          resolve(encryptedKey)\n        }).catch(err => {\n          reject(err)\n        })\n      } else {\n        throw new TypeError('Expected input of wrappingKey is not a supported key')\n      }\n    })\n  }\n\n  /**\n   * Method that decrypts keys\n   * @param {CryptoKey} unwrappingKey default: \"undefined\"\n   * @param {String} encryptedKey default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- AES-GCM: { type: 'raw', name: 'AES-GCM', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- AES-CBC: { type: 'raw', name: 'AES-CBC', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- ECDH: { type: \"'pkcs8' or 'spki'\", name: 'ECDH', namedCurve: 'P-256', usages: ['deriveKey', 'deriveBits'], isExtractable: true }\n   * -- ECDSA: { type: \"'pkcs8' or 'spki'\", name: 'ECDSA', namedCurve: 'P-256', usages: ['sign', 'verify'], isExtractable: true }\n   * -- RSA-OAEP: { type: \"'pkcs8' or 'spki'\", name: 'RSA-OAEP', hash: 'SHA-512', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n   * -- RSA-PSS: { type: \"'pkcs8' or 'spki'\", name: 'RSA-PSS', hash: 'SHA-512', usages: ['sign', 'verify'], isExtractable: true }\n   */\n  decryptKey (unwrappingKey, encryptedKey, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.name = (typeof options.name !== 'undefined') ? options.name : 'AES-GCM'\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(unwrappingKey) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of unwrappingKey to be a CryptoKey Object')\n      }\n\n      if (typeof encryptedKey !== 'string') {\n        throw new TypeError('Expected input of encryptedKey to be a Base64 String')\n      }\n\n      if (typeof options.name !== 'string') {\n        throw new TypeError('Expected input of options.name to be a String')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      const keyOptions = {}\n      keyOptions.name = options.name\n\n      if (options.name === 'AES-GCM' || options.name === 'AES-CBC') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'raw'\n        options.length = (typeof options.length !== 'undefined') ? options.length : 256\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n\n        if (typeof options.length !== 'number') {\n          throw new TypeError('Expected input of options.length to be a Number')\n        }\n      } else if (options.name === 'ECDH') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.namedCurve = (typeof options.namedCurve !== 'undefined') ? options.namedCurve : 'P-256'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['deriveKey', 'deriveBits']\n\n        if (typeof options.namedCurve !== 'string') {\n          throw new TypeError('Expected input of options.namedCurve to be a String')\n        }\n\n        keyOptions.namedCurve = options.namedCurve\n      } else if (options.name === 'ECDSA') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.namedCurve = (typeof options.namedCurve !== 'undefined') ? options.namedCurve : 'P-256'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n\n        if (typeof options.namedCurve !== 'string') {\n          throw new TypeError('Expected input of options.namedCurve to be a String')\n        }\n\n        keyOptions.namedCurve = options.namedCurve\n      } else if (options.name === 'RSA-OAEP') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['decrypt', 'unwrapKey']\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else if (options.name === 'RSA-PSS') {\n        options.type = (typeof options.type !== 'undefined') ? options.type : 'pkcs8'\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n        options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['sign']\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        keyOptions.hash = {}\n        keyOptions.hash.name = options.hash\n      } else {\n        throw new TypeError('Expected input of options.name is not a valid algorithm name')\n      }\n\n      if (typeof options.type !== 'string') {\n        throw new TypeError('Expected input of options.type to be a String')\n      }\n\n      if (typeof options.usages !== 'object') {\n        throw new TypeError('Expected input of options.usages to be an Array')\n      }\n\n      if (unwrappingKey.type === 'secret') {\n        let ivB64 = null\n        let encryptedKeyB64 = null\n\n        if (unwrappingKey.algorithm.name === 'AES-GCM') {\n          ivB64 = encryptedKey.substring(0, 16)\n          encryptedKeyB64 = encryptedKey.substring(16)\n        } else if (unwrappingKey.algorithm.name === 'AES-CBC') {\n          ivB64 = encryptedKey.substring(0, 24)\n          encryptedKeyB64 = encryptedKey.substring(24)\n        } else {\n          throw new TypeError('Cipher mode of the wrappingKey is not supported')\n        }\n\n        const ivAb = self.base64ToArrayBuffer(ivB64)\n        const encryptedKeyAb = self.base64ToArrayBuffer(encryptedKeyB64)\n\n        cryptoApi.unwrapKey(\n          options.type,\n          encryptedKeyAb,\n          unwrappingKey,\n          {\n            name: unwrappingKey.algorithm.name,\n            iv: ivAb,\n            tagLength: 128\n          },\n          keyOptions,\n          options.isExtractable,\n          options.usages\n        ).then(decryptedKey => {\n          resolve(decryptedKey)\n        }).catch(err => {\n          reject(err)\n        })\n      } else if (unwrappingKey.algorithm.name === 'RSA-OAEP') {\n        if (unwrappingKey.type !== 'private') {\n          throw new TypeError('Expected input of unwrappingKey to be a CryptoKey Object of type private')\n        }\n\n        const encryptedKeyAb = self.base64ToArrayBuffer(encryptedKey)\n\n        cryptoApi.unwrapKey(\n          options.type,\n          encryptedKeyAb,\n          unwrappingKey,\n          {\n            name: 'RSA-OAEP',\n            modulusLength: unwrappingKey.algorithm.modulusLength,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n            hash: { name: unwrappingKey.algorithm.hash.name }\n          },\n          keyOptions,\n          options.isExtractable,\n          options.usages\n        ).then(decryptedKey => {\n          resolve(decryptedKey)\n        }).catch(err => {\n          reject(err)\n        })\n      } else {\n        throw new TypeError('Expected input of unwrappingKey is not a supported key')\n      }\n    })\n  }\n\n  /**\n   * Method that generates key signature using ECDSA or RSA-PSS\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   * @param {CryptoKey} key default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDSA: { hash: 'SHA-512' }\n   * -- RSA-PSS: { saltLength: 128 }\n   */\n  signKey (privateKey, key, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input of privateKey to be a CryptoKey Object of type private')\n      }\n\n      if (Object.prototype.toString.call(key) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of key to be a CryptoKey Object')\n      }\n\n      cryptoApi.exportKey(\n        'raw',\n        key\n      ).then(keyAb => {\n        if (privateKey.algorithm.name === 'ECDSA') {\n          options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n  \n          if (typeof options.hash !== 'string') {\n            throw new TypeError('Expected input of options.hash to be a String')\n          }\n  \n          cryptoApi.sign(\n            {\n              name: 'ECDSA',\n              hash: { name: options.hash }\n            },\n            privateKey,\n            keyAb\n          ).then(signatureAb => {\n            const signatureB64 = self.arrayBufferToBase64(signatureAb)\n            resolve(signatureB64)\n          }).catch(err => {\n            reject(err)\n          })\n        } else if (privateKey.algorithm.name === 'RSA-PSS') {\n          options.saltLength = (typeof options.saltLength !== 'undefined') ? options.saltLength : 128\n  \n          if (typeof options.saltLength !== 'number') {\n            throw new TypeError('Expected input of options.saltLength to be a Number')\n          }\n  \n          cryptoApi.sign(\n            {\n              name: 'RSA-PSS',\n              saltLength: options.saltLength\n            },\n            privateKey,\n            keyAb\n          ).then(signatureAb => {\n            const signatureB64 = self.arrayBufferToBase64(signatureAb)\n            resolve(signatureB64)\n          }).catch(err => {\n            reject(err)\n          })\n        } else {\n          throw new TypeError('Expected input of privateKey is not a valid private key')\n        }\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that verifies key signature using ECDSA or RSA-PSS\n   * @param {CryptoKey} publicKey default: \"undefined\"\n   * @param {CryptoKey} key default: \"undefined\"\n   * @param {String} signature default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDSA: { hash: 'SHA-512' }\n   * -- RSA-PSS: { saltLength: 128 }\n   */\n  verifyKey (publicKey, key, signature, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(publicKey) !== '[object CryptoKey]' && publicKey.type !== 'public') {\n        throw new TypeError('Expected input of publicKey to be a CryptoKey Object of type public')\n      }\n\n      if (Object.prototype.toString.call(key) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of key to be a CryptoKey Object')\n      }\n\n      if (typeof signature !== 'string') {\n        throw new TypeError('Expected input of signature to be a Base64 String')\n      }\n      \n      const signatureAb = self.base64ToArrayBuffer(signature)\n\n      cryptoApi.exportKey(\n        'raw',\n        key\n      ).then(keyAb => {\n        if (publicKey.algorithm.name === 'ECDSA') {\n          options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n  \n          if (typeof options.hash !== 'string') {\n            throw new TypeError('Expected input of options.hash to be a String')\n          }\n  \n          cryptoApi.verify(\n            {\n              name: 'ECDSA',\n              hash: { name: options.hash }\n            },\n            publicKey,\n            signatureAb,\n            keyAb\n          ).then(isValid => {\n            resolve(isValid)\n          }).catch(err => {\n            reject(err)\n          })\n        } else if (publicKey.algorithm.name === 'RSA-PSS') {\n          cryptoApi.verify(\n            {\n              name: 'RSA-PSS',\n              saltLength: 128\n            },\n            publicKey,\n            signatureAb,\n            keyAb\n          ).then(isValid => {\n            resolve(isValid)\n          }).catch(err => {\n            reject(err)\n          })\n        } else {\n          throw new TypeError('Expected input of publicKey is not a valid public key')\n        }\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that generates signature of data using ECDSA or RSA-PSS\n   * @param {CryptoKey} privateKey default: \"undefined\"\n   * @param {ArrayBuffer} data default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDSA: { hash: 'SHA-512' }\n   * -- RSA-PSS: { saltLength: 128 }\n   */\n  sign (privateKey, data, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(privateKey) !== '[object CryptoKey]' && privateKey.type !== 'private') {\n        throw new TypeError('Expected input of privateKey to be a CryptoKey Object of type private')\n      }\n\n      if (typeof data !== 'object') {\n        throw new TypeError('Expected input of data to be an ArrayBuffer')\n      }\n\n      if (privateKey.algorithm.name === 'ECDSA') {\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        cryptoApi.sign(\n          {\n            name: 'ECDSA',\n            hash: { name: options.hash }\n          },\n          privateKey,\n          data\n        ).then(signatureAb => {\n          const signatureB64 = self.arrayBufferToBase64(signatureAb)\n          resolve(signatureB64)\n        }).catch(err => {\n          reject(err)\n        })\n      } else if (privateKey.algorithm.name === 'RSA-PSS') {\n        options.saltLength = (typeof options.saltLength !== 'undefined') ? options.saltLength : 128\n\n        if (typeof options.saltLength !== 'number') {\n          throw new TypeError('Expected input of options.saltLength to be a Number')\n        }\n\n        cryptoApi.sign(\n          {\n            name: 'RSA-PSS',\n            saltLength: options.saltLength\n          },\n          privateKey,\n          data\n        ).then(signatureAb => {\n          const signatureB64 = self.arrayBufferToBase64(signatureAb)\n          resolve(signatureB64)\n        }).catch(err => {\n          reject(err)\n        })\n      } else {\n        throw new TypeError('Expected input of privateKey is not a valid private key')\n      }\n    })\n  }\n\n  /**\n   * Method that verifies data signature using ECDSA or RSA-PSS\n   * @param {CryptoKey} publicKey default: \"undefined\"\n   * @param {ArrayBuffer} data default: \"undefined\"\n   * @param {String} signature default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- ECDSA: { hash: 'SHA-512' }\n   * -- RSA-PSS: { saltLength: 128 }\n   */\n  verify (publicKey, data, signature, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(publicKey) !== '[object CryptoKey]' && publicKey.type !== 'public') {\n        throw new TypeError('Expected input of publicKey to be a CryptoKey Object of type public')\n      }\n\n      if (typeof data !== 'object') {\n        throw new TypeError('Expected input of data to be an ArrayBuffer')\n      }\n\n      if (typeof signature !== 'string') {\n        throw new TypeError('Expected input of signature to be a Base64 String')\n      }\n      \n      const signatureAb = self.base64ToArrayBuffer(signature)\n\n      if (publicKey.algorithm.name === 'ECDSA') {\n        options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n\n        if (typeof options.hash !== 'string') {\n          throw new TypeError('Expected input of options.hash to be a String')\n        }\n\n        cryptoApi.verify(\n          {\n            name: 'ECDSA',\n            hash: { name: options.hash }\n          },\n          publicKey,\n          signatureAb,\n          data\n        ).then(isValid => {\n          resolve(isValid)\n        }).catch(err => {\n          reject(err)\n        })\n      } else if (publicKey.algorithm.name === 'RSA-PSS') {\n        cryptoApi.verify(\n          {\n            name: 'RSA-PSS',\n            saltLength: 128\n          },\n          publicKey,\n          signatureAb,\n          data\n        ).then(isValid => {\n          resolve(isValid)\n        }).catch(err => {\n          reject(err)\n        })\n      } else {\n        throw new TypeError('Expected input of publicKey is not a valid public key')\n      }\n    })\n  }\n\n  /**\n   * Method that encrypts data using symmetric/shared key\n   * @param {CryptoKey} sharedKey default: \"undefined\"\n   * @param {ArrayBuffer} data default: \"undefined\"\n   */\n  encrypt (sharedKey, data) {\n    const self = this\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(sharedKey) !== '[object CryptoKey]' && sharedKey.type !== 'secret') {\n        throw new TypeError('Expected input of sharedKey to be a CryptoKey Object')\n      }\n\n      if (typeof data !== 'object') {\n        throw new TypeError('Expected input of data to be an ArrayBuffer')\n      }\n\n      let ivAb = null\n\n      if (sharedKey.algorithm.name === 'AES-GCM') {\n        ivAb = cryptoLib.getRandomValues(new Uint8Array(12))\n      } else if (sharedKey.algorithm.name === 'AES-CBC') {\n        ivAb = cryptoLib.getRandomValues(new Uint8Array(16))\n      } else {\n        throw new TypeError('Cipher mode of the sharedKey is not supported')\n      }\n\n      cryptoApi.encrypt(\n        {\n          name: sharedKey.algorithm.name,\n          iv: ivAb,\n          tagLength: 128\n        },\n        sharedKey,\n        data\n      ).then(encryptedAb => {\n        const ivB64 = self.arrayBufferToBase64(ivAb)\n        const encryptedB64 = self.arrayBufferToBase64(encryptedAb)\n\n        resolve(ivB64 + encryptedB64)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that decrypts data using symmetric/shared key\n   * @param {CryptoKey} sharedKey default: \"undefined\"\n   * @param {String} encryptedData default: \"undefined\"\n   * @param {Object} options default: depends on algorithm below\n   * -- AES-GCM: { cipher: 'AES-GCM' }\n   * -- AES-CBC: { cipher: 'AES-CBC' }\n   */\n  decrypt (sharedKey, encryptedData, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.cipher = (typeof options.cipher !== 'undefined') ? options.cipher : 'AES-GCM'\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(sharedKey) !== '[object CryptoKey]' && sharedKey.type !== 'secret') {\n        throw new TypeError('Expected input of sharedKey to be a CryptoKey Object')\n      }\n\n      if (typeof encryptedData !== 'string') {\n        throw new TypeError('Expected input of encryptedData to be a String')\n      }\n\n      if (typeof options.cipher !== 'string') {\n        throw new TypeError('Expected input of options.cipher to be a String')\n      }\n\n      let ivB64 = null\n      let encryptedB64 = null\n\n      if (options.cipher === 'AES-GCM') {\n        ivB64 = encryptedData.substring(0, 16)\n        encryptedB64 = encryptedData.substring(16)\n      } else if (options.cipher === 'AES-CBC') {\n        ivB64 = encryptedData.substring(0, 24)\n        encryptedB64 = encryptedData.substring(24)\n      } else {\n        throw new TypeError('Cipher mode of the sharedKey is not supported')\n      }\n\n      const ivAb = self.base64ToArrayBuffer(ivB64)\n      const encryptedAb = self.base64ToArrayBuffer(encryptedB64)\n\n      cryptoApi.decrypt(\n        {\n          name: options.cipher,\n          iv: ivAb,\n          tagLength: 128\n        },\n        sharedKey,\n        encryptedAb\n      ).then(decryptedDataAb => {\n        resolve(decryptedDataAb)\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that derives shared key from passphrase\n   * @param {String} passphrase default: \"undefined\"\n   * @param {ArrayBuffer} salt default: \"undefined\"\n   * @param {Number} iterations default: \"64000\"\n   * @param {Object} options default: \"{ hash: 'SHA-512', length: 256, cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\"\n   */\n  derivePassphraseKey (passphrase, salt, iterations, options) {\n    const self = this\n\n    iterations = (typeof iterations !== 'undefined') ? iterations : 64000\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n    options.length = (typeof options.length !== 'undefined') ? options.length : 256\n    options.cipher = (typeof options.cipher !== 'undefined') ? options.cipher : 'AES-GCM'\n    options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof passphrase !== 'string') {\n        throw new TypeError('Expected input of passphrase to be a String')\n      }\n\n      if (typeof salt !== 'object') {\n        throw new TypeError('Expected input of salt to be an ArrayBuffer')\n      }\n\n      if (typeof iterations !== 'number') {\n        throw new TypeError('Expected input of iterations to be a Number')\n      }\n\n      if (typeof options.hash !== 'string') {\n        throw new TypeError('Expected input of options.hash to be a String')\n      }\n\n      if (typeof options.length !== 'number') {\n        throw new TypeError('Expected input of options.length to be a Number')\n      }\n\n      if (typeof options.cipher !== 'string') {\n        throw new TypeError('Expected input of options.cipher to be a String')\n      }\n\n      if (typeof options.usages !== 'object') {\n        throw new TypeError('Expected input of options.usages to be an Array')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      const passphraseAb = self.stringToArrayBuffer(passphrase)\n\n      cryptoApi.importKey(\n        'raw',\n        passphraseAb,\n        {\n          name: 'PBKDF2'\n        },\n        false,\n        ['deriveKey']\n      ).then(baseKey => {\n        cryptoApi.deriveKey(\n          {\n            name: 'PBKDF2',\n            salt: salt,\n            iterations: iterations,\n            hash: { name: options.hash }\n          },\n          baseKey,\n          {\n            name: options.cipher,\n            length: options.length\n          },\n          options.isExtractable,\n          options.usages\n        ).then(derivedKey => {\n          resolve(derivedKey)\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that derives hash from passphrase\n   * @param {String} passphrase default: \"undefined\"\n   * @param {ArrayBuffer} salt default: \"undefined\" salt\n   * @param {Number} iterations default: \"64000\"\n   * @param {Object} options default: \"{ hash: 'SHA-512', length: 256, cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\"\n   */\n  hashPassphrase (passphrase, salt, iterations, options) {\n    const self = this\n\n    iterations = (typeof iterations !== 'undefined') ? iterations : 64000\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.hash = (typeof options.hash !== 'undefined') ? options.hash : 'SHA-512'\n    options.length = (typeof options.length !== 'undefined') ? options.length : 256\n    options.cipher = (typeof options.cipher !== 'undefined') ? options.cipher : 'AES-GCM'\n    options.usages = (typeof options.usages !== 'undefined') ? options.usages : ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n    options.isExtractable = (typeof options.isExtractable !== 'undefined') ? options.isExtractable : true\n\n    return new Promise((resolve, reject) => {\n      if (typeof passphrase !== 'string') {\n        throw new TypeError('Expected input of passphrase to be a String')\n      }\n\n      if (typeof salt !== 'object') {\n        throw new TypeError('Expected input of salt to be an ArrayBuffer')\n      }\n\n      if (typeof iterations !== 'number') {\n        throw new TypeError('Expected input of iterations to be a Number')\n      }\n\n      if (typeof options.hash !== 'string') {\n        throw new TypeError('Expected input of options.hash to be a String')\n      }\n\n      if (typeof options.length !== 'number') {\n        throw new TypeError('Expected input of options.length to be a Number')\n      }\n\n      if (typeof options.cipher !== 'string') {\n        throw new TypeError('Expected input of options.cipher to be a String')\n      }\n\n      if (typeof options.usages !== 'object') {\n        throw new TypeError('Expected input of options.usages to be an Array')\n      }\n\n      if (typeof options.isExtractable !== 'boolean') {\n        throw new TypeError('Expected input of options.isExtractable to be a Boolean')\n      }\n\n      self.derivePassphraseKey(passphrase, salt, iterations, options).then(derivedKey => {\n        cryptoApi.exportKey(\n          'raw',\n          derivedKey\n        ).then(exportedKeyAb => {\n          const derivedHash = self.arrayBufferToHexString(exportedKeyAb)\n          resolve(derivedHash)\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that generates fingerprint of EC, RSA and AES keys\n   * @param {CryptoKey} key default: \"undefined\"\n   * @param {Object} options default: { hash: 'SHA-512', isBuffer: false }\n   */\n  getFingerprint (key, options) {\n    const self = this\n\n    if (typeof options === 'undefined') {\n      options = {}\n    }\n\n    options.hash = (typeof hash !== 'undefined') ? hash : 'SHA-512'\n    options.isBuffer = (typeof options.isBuffer !== 'undefined') ? options.isBuffer : false\n\n    return new Promise((resolve, reject) => {\n      if (Object.prototype.toString.call(key) !== '[object CryptoKey]') {\n        throw new TypeError('Expected input of key to be a CryptoKey Object')\n      }\n\n      if (typeof options.hash !== 'string') {\n        throw new TypeError('Expected input of options.hash to be a String')\n      }\n\n      if (typeof options.isBuffer !== 'boolean') {\n        throw new TypeError('Expected input of options.isBuffer to be a Boolean')\n      }\n\n      let keyType = null\n      switch (key.type) {\n        case 'secret' :\n          keyType = 'raw'\n          break\n        case 'private' :\n          keyType = 'pkcs8'\n          break\n        case 'public' :\n          keyType = 'spki'\n      }\n\n      cryptoApi.exportKey(\n        keyType,\n        key\n      ).then(keyAb => {\n        cryptoApi.digest(\n          {\n            name: options.hash\n          },\n          keyAb\n        ).then(fingerprintAb => {\n          if (options.isBuffer) {\n            resolve(fingerprintAb)\n          } else {\n            const hexFingerprint = self.arrayBufferToHexString(fingerprintAb)\n            resolve(hexFingerprint)\n          }\n        }).catch(err => {\n          reject(err)\n        })\n      }).catch(err => {\n        reject(err)\n      })\n    })\n  }\n\n  /**\n   * Method that generates random bytes using cryptographically secure PRNG\n   * @param {Number} size default: \"16\"\n   */\n  getRandomBytes (size) {\n    size = (typeof size !== 'undefined') ? size : 16\n\n    return new Promise((resolve, reject) => {\n      if (typeof size !== 'number') {\n        throw new TypeError('Expected input of size to be a Number')\n      }\n\n      const data = cryptoLib.getRandomValues(new Uint8Array(size))\n\n      resolve(data)\n    })\n  }\n}\n","const Utils={};\n\nconst _baseChars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nUtils.clone=function(o) {\n\treturn window.structuredClone(o);\n}\n\nUtils.frozenClone=function(o) {\n\treturn Object.freeze(Utils.clone(o));\n}\n\n// async sleep\nUtils.sleep=function(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n\nfunction _random() {\n\tlet rnda=crypto.getRandomValues(new Uint32Array(1));\n\treturn rnda[0] / (4294967295 + 1); // max + 1 to ensure n<1\n}\n\nfunction _randomInteger(bottom, top) {\n\tbottom=Math.max(0, bottom || 0);\n\ttop=Math.min(Number.MAX_SAFE_INTEGER, top=top || Number.MAX_SAFE_INTEGER);\n\treturn Math.floor( _random() * ( 1 + top - bottom ) ) + bottom;\n};\n\nUtils.unique=function(len, base) {\n\tlen=Math.max(1, len || 20);\n\tbase=Math.max(2, Math.min(62, base || 62))-1;\n\n\tvar u='';\n\tfor (var i=0;i<len;i++) u+=_baseChars[_randomInteger(0, base)];\n\treturn u;\n}\n\nexport default Utils","import LZString from 'lz-string';\nimport OpenCrypto from 'opencrypto';\n\nimport Utils from './utils';\n\nconst cryptoLib = window.crypto || window.msCrypto;\nconst cryptoApi = cryptoLib.subtle || cryptoLib.webkitSubtle;\n\nconst SEnclave={};\n\nconst crypt=new OpenCrypto();\n\nconst _state={};\nconst _keystore={};\nconst _prvstore={};\n\nfunction _resetObject(obj) {\n\tfor (var p in obj) delete obj[p];\n}\n\nfunction _resetMemory() {\n\t_resetObject(_prvstore);\n\t_resetObject(_keystore);\n\tObject.assign(_prvstore, {\n\t\tversion:1,\n\t\tuser:false,\n\t\tstate:'uninitialized',\n\t\tdeviceId:Utils.unique(30),\n\t\tsessionId:Utils.unique(30)\n\t});\n}\n_resetMemory();\n\n// export getters\n['user','state','deviceId','sessionId','version'].forEach(function(prop) {\n\tObject.defineProperty(SEnclave, prop, { \n\t\tget: function() { return _prvstore[prop]; } \n\t});\n});\n\n['tkn'].forEach(function(prop) {\n\tObject.defineProperty(SEnclave, prop, { \n\t\tget: function() { return _keystore[prop]; } \n\t});\n});\n\n\nfunction _setState(state) {\n\tif (state==_prvstore.state) return;\n\t_prvstore.state=state;\n\tconsole.info('SEnclave.state', state);\n}\n\n\nfunction _generateRecoveryKey() {\n\tvar parts=[];\n\tfor(var i=0;i<3;i++) {\n\t\tparts.push(Utils.unique(6,32));\n\t}\n\treturn parts.join('-');\n}\n\nasync function _passwordHash(email, password) {\n\tvar salt=crypt.stringToArrayBuffer(email);\n\tvar passwordHash=await crypt.hashPassphrase(password, salt, 800102, { hash: 'SHA-512', length: 256, cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true });\n\t// convert hex to base64\n\tpasswordHash=crypt.arrayBufferToBase64(crypt.hexStringToArrayBuffer(passwordHash));\n\treturn passwordHash;\n}\n\nfunction _removePemHeaders(pem) {\n\treturn pem.replace(/^--.*--$/gm,'').replace(/[\\r\\n]/g,''); // remove lines and --- headers\n}\n\n// create new keys\nasync function _createAccountKeys(email, password) {\n\tvar iKeyPair=await crypt.getRSAKeyPair(2048, \"SHA-512\", \"RSA-OAEP\", ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], true);\n\n\tvar ePrvKey=await crypt.encryptPrivateKey(iKeyPair.privateKey, password, 800100, \"SHA-512\", \"AES-GCM\", 256);\n\tePrvKey=_removePemHeaders(ePrvKey);\n\tvar ePubKey=await crypt.cryptoPublicToPem(iKeyPair.publicKey);\n\tePubKey=_removePemHeaders(ePubKey);\n\tvar hPwd=await _passwordHash(email, password);\n\n\t// recovery\n\tvar cRecKey=_generateRecoveryKey();\n\tvar sRecKey=_generateRecoveryKey();\n\n\tvar iPemPrvKey=await crypt.cryptoPrivateToPem(iKeyPair.privateKey);\n\tiPemPrvKey=_removePemHeaders(iPemPrvKey);\n\tvar iRec=JSON.stringify({ts:Date.now(), hPwd:hPwd, iPrvKey:iPemPrvKey});\n\n\tvar rPass=[cRecKey, sRecKey].join('-');\n\tvar salt=crypt.stringToArrayBuffer(email);\n\tvar iKey=await crypt.derivePassphraseKey(rPass, salt, 800100, { hash: 'SHA-512', length: 256, cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: false });\n\tvar eRec=await crypt.encrypt(iKey, crypt.stringToArrayBuffer(iRec));\n\n\t// shared key\n\tvar iShrKey=await crypt.getSharedKey(256, {cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true });\n\tvar eShrKey=await crypt.encryptKey(iKeyPair.publicKey, iShrKey);\n\n\tvar keys={\n\t\thPwd:hPwd,\n\t\tePubKey:ePubKey,\n\t\tePrvKey:ePrvKey,\n\t\tcRecKey:cRecKey,\n\t\tsRecKey:sRecKey,\n\t\teShrKey:eShrKey,\n\t\tiShrKey:iShrKey,\n\t\teRec:eRec\n\t}\n\n\treturn keys;\n}\n\n\n\nasync function _decryptUserKeys(user, password) {\n\tif (!user || !user.ekeys) return false;\n\ttry {\n\t\tvar ekeys=user.ekeys;\n\t\tvar keys={};\n\t\tkeys.iPrvKey=await crypt.decryptPrivateKey(ekeys.ePrvKey, password, { name: 'RSA-OAEP', hash: 'SHA-512', usages: ['decrypt', 'unwrapKey'], isExtractable: false});\n\t\tkeys.iPubKey=await crypt.pemPublicToCrypto(ekeys.ePubKey, { name: 'RSA-OAEP', hash: 'SHA-512', usages: ['encrypt', 'wrapKey'], isExtractable: false});\n\t\tkeys.iShrKey=await crypt.decryptKey(keys.iPrvKey, ekeys.eShrKey, { type: 'raw', name: 'AES-GCM', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: false});\n\n\t\treturn keys;\n\t} catch(ex) {\n\t\tconsole.error(ex);\n\t}\t\n\treturn false;\n}\n\nSEnclave.signup=async function(email, password, code) {\n\tvar ekeys=await _createAccountKeys(email, password);\n\n\tvar user={\n\t\temail:email\n\t};\n\tuser.ekeys={\n\t\tePrvKey:ekeys.ePrvKey, ePubKey:ekeys.ePubKey,\n\t\tcRecKey:ekeys.cRecKey, eRec:ekeys.eRec, eShrKey:ekeys.eShrKey,\n\t}\n\n\t_prvstore.user=Utils.frozenClone(user);\n\n\treturn SEnclave.signin(email, password);\n}\n\nSEnclave.signin=async function(email, password) {\n\tif (_state.signinLock) return {error:'lock'};\n\t_state.signinLock=true;\n\tif (_prvstore.user) {\n\t\tif (_prvstore.user.email!=email) {\n\t\t\tawait Utils.sleep(200);\n\t\t\t_state.signinLock=false;\n\t\t\treturn {error:'email'}\n\t\t};\n\t\t_setState('unlocking');\n\t\tvar keys=await _decryptUserKeys(_prvstore.user, password);\n\t\tif (!keys) {\n\t\t\tawait Utils.sleep(200);\n\t\t\t_setState('locked');\n\t\t\t_state.signinLock=false;\n\t\t\treturn {error:'password'};\n\t\t}\n\n\t\tfor (var k in _keystore) {delete _keystore[k];}\n\t\t_keystore.ready=true;\n\t\tfor(var k in keys) {_keystore[k]=keys[k];}\n\t\t_setState('unlocked');\n\t\t_state.signinLock=false;\n\t\treturn _prvstore.user;\n\t}\n\tawait Utils.sleep(200);\n\t_state.signinLock=false;\n\treturn {error:'user'};\n}\n\nSEnclave.logout=async function() {\n\tif (_prvstore.state!='unlocked') return false;\n\t_setState('uninitialized');\n\t_resetMemory();\n\treturn true;\n}\n\n\n// decrypt AES-GCM-256 key\nasync function _decryptKey(eKey, extractable) {\n\tif (!_keystore.ready) return false;\n\ttry {\n\t\tvar iKey=await crypt.decryptKey(\n\t\t\t_keystore.iPrvKey, eKey, \n\t\t\t{type: 'raw', name: 'AES-GCM', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: false }\n\t\t);\n\t\treturn iKey;\n\t} catch(ex) {}\n\treturn false;\n}\n\n// create random AES-GCM-256 KEY\n/*\nSEnclave.generateKey=async function() {\n\tvar iKey=await crypt.getSharedKey(\n\t\t256, {cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n\t);\n\treturn await crypt.cryptoToBase64(iKey);\n}\n*/\n\nSEnclave.generateEncryptedKey=async function() {\n\tif (!_keystore.ready) return false;\n\tvar iKey=await crypt.getSharedKey(\n\t\t256, {cipher: 'AES-GCM', usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: true }\n\t);\n\tvar eKey=await crypt.encryptKey(_keystore.iPubKey, iKey);\n\treturn eKey;\n}\n\nfunction _concatArrayBuffers() {\n\tvar length=0;\n\tvar buffers=[];\n\tfor(var i=0,l=arguments.length;i<l;i++) {\n\t\tvar buffer=false;\n\t\tvar arg=arguments[i];\n\t\tvar type=typeof(arg);\n\t\tif (type==='number') {\n\t\t\tbuffer=new Uint8Array([arg]);\n\t\t} else if (type==='object') {\n\t\t\ttype=Object.prototype.toString.call(arg);\n\t\t\tif (type==='[object ArrayBuffer]') {\n\t\t\t\tbuffer=new Uint8Array(arg);\n\t\t\t} else if (type==='[object Uint8Array]') {\n\t\t\t\tbuffer=arg;\n\t\t\t}\n\t\t}\t\n\t\tif (!buffer) continue;\n\t\tlength+=buffer.length\n\t\tbuffers.push(buffer);\n\t}\n\n\tvar bytea=new Uint8Array(length);\n\tvar pos=0;\n\tfor(var i=0,l=buffers.length;i<l;i++) {\n\t\tvar buffer=buffers[i];\n\t\tbytea.set(buffer, pos);\n\t\tpos+=buffer.length;\n\t}\n\treturn bytea.buffer;\n}\n\nasync function _encryptRaw(data, opt) {\n\tvar se=this;\n\topt=opt||{};\n\tvar edata=null;\n\ttry {\n\t\tlet ivAb = cryptoLib.getRandomValues(new Uint8Array(12)); // GCM is 12\n\t\tvar encryptedAb = await cryptoApi.encrypt(\n\t\t\t{name: 'AES-GCM', iv: ivAb, tagLength: 128},\n\t\t\tse._key,\n\t\t\tdata\n\t\t);\n\t\tedata=_concatArrayBuffers(ivAb, encryptedAb);\n\t} catch(ex) {\n\t\tconsole.error(ex);\n\t}\n\treturn edata;\n}\n\nasync function _decryptRaw(edata, opt) {\n\tvar se=this;\n\topt=opt||{};\n\tvar data=null;\n\ttry {\n\t\tlet ivAb=new Uint8Array(edata.slice(0,12));\n\t\tedata=edata.slice(12);\n\t\tdata=await cryptoApi.decrypt(\n\t\t\t{name: 'AES-GCM', iv: ivAb, tagLength: 128},\n\t\t\tse._key,\n\t\t\tedata\n\t\t);\n\t} catch {}\n\treturn data;\n}\n\n// OBJECT > JSON > encode > encrypt > EBASE64\nasync function _encrypt(data) {\n\tvar se=this;\n\n\tdata=JSON.stringify(data);\n\n\tvar edata=null;\n\t// 0: pure string, 2: lzstring\n\tvar encodetype=2;\n\tvar ab=null;\n\tswitch(encodetype) {\n\t\tcase 2:\n\t\t\tab=LZString.compressToUint8Array(data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tencodetype=0;\n\t\t\tab=crypt.stringToArrayBuffer(data);\n\t\t\tbreak;\n\t}\n\n\tif (ab==null) return null;\n\tdata=_concatArrayBuffers(encodetype, ab);\n\tedata=await se.encryptRaw(data);\n\tif (edata===null) return null;\n\treturn crypt.arrayBufferToBase64(edata);\n}\n\n// EBASE64 > decrypt >  decode > JSON > OBJECT\nasync function _decrypt(edata) {\n\tvar se=this;\n\n\tvar data=null;\n\ttry {\n\t\tvar abdata=await se.decryptRaw(crypt.base64ToArrayBuffer(edata));\n\t\tvar encodetype=(new Uint8Array(abdata.slice(0,1)))[0];\n\t\tabdata=abdata.slice(1);\n\t\tvar str=null;\n\t\tswitch(encodetype) {\n\t\t\tcase 2:\n\t\t\t\tstr=LZString.decompressFromUint8Array(new Uint8Array(abdata));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr=crypt.arrayBufferToString(abdata);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (str==null) return null;\n\t\tdata=JSON.parse(str);\n\t} catch {}\n\treturn data;\n}\n\n\nasync function _encryptProps(obj, opt) {\n\tvar se=this;\n\tvar nobj={};\n\n\topt=opt||{};\n\n\tvar fn=function(prop) {\n\t\tif (prop[0]==\"_\") return \"$\"+prop.substring(1);\n\t\treturn false;\n\t};\n\tfor(var prop in obj) {\n\t\tvar nprop=fn(prop);\n\t\tnobj[nprop || prop]=(nprop)?await se.encrypt(obj[prop]):Utils.clone(obj[prop]);\n\t}\n\treturn nobj;\n}\n\nasync function _decryptProps(obj, opt) {\n\tvar se=this;\n\tvar nobj={};\n\n\topt=opt||{};\n\tvar fn=function(prop) {\n\t\tif (prop[0]==\"$\") return \"_\"+prop.substring(1);\n\t\treturn false;\n\t};\n\n\tfor(var prop in obj) {\n\t\tvar nprop=fn(prop);\n\t\tnobj[nprop || prop]=(nprop)?await se.decrypt(obj[prop]):Utils.clone(obj[prop]);\n\t}\n\treturn nobj;\n}\n\nSEnclave.create=async function(opt) {\n\tvar iKey=false;\n\ttry {\n\t\tif (opt.ekey) {\n\t\t\tiKey=await _decryptKey(opt.ekey);\n\t\t} else if (opt.key) {\n\t\t\tiKey=await crypt.base64ToCrypto(opt.key, { name: 'AES-GCM', length: 256, usages: ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'], isExtractable: false});\n\t\t}\n\t} catch {\n\t\treturn false;\n\t}\n\tif (!iKey) return false;\n\n\n\tvar se={\n\t\t_key:iKey\n\t};\n\n\tse.encrypt=_encrypt.bind(se);\n\tse.decrypt=_decrypt.bind(se);\n\tse.encryptProps=_encryptProps.bind(se);\n\tse.decryptProps=_decryptProps.bind(se);\n\tse.encryptRaw=_encryptRaw.bind(se);\n\tse.decryptRaw=_decryptRaw.bind(se);\n\t\n\treturn {\n\t\tencrypt:se.encrypt,\n\t\tdecrypt:se.decrypt,\n\t\tencryptProps:se.encryptProps,\n\t\tdecryptProps:se.decryptProps,\n\t\tencryptRaw:se.encryptRaw,\n\t\tdecryptRaw:se.decryptRaw\n\t};\n};\n\n\nexport default SEnclave;"],"names":["LZString","f","String","fromCharCode","keyStrBase64","keyStrUriSafe","baseReverseDic","getBaseValue","alphabet","character","i","length","charAt","compressToBase64","input","res","_compress","a","decompressFromBase64","_decompress","index","compressToUTF16","decompressFromUTF16","compressed","charCodeAt","compressToUint8Array","uncompressed","compress","buf","Uint8Array","TotalLen","current_value","decompressFromUint8Array","decompress","Array","result","forEach","c","push","join","compressToEncodedURIComponent","decompressFromEncodedURIComponent","replace","bitsPerChar","getCharFromInt","value","ii","context_dictionary","context_dictionaryToCreate","context_c","context_wc","context_w","context_enlargeIn","context_dictSize","context_numBits","context_data","context_data_val","context_data_position","Object","prototype","hasOwnProperty","call","Math","pow","resetValue","getNextValue","w","bits","resb","maxpower","power","dictionary","enlargeIn","dictSize","numBits","entry","data","val","position","module","angular","factory","cryptoLib","window","crypto","msCrypto","cryptoApi","subtle","webkitSubtle","chars","lookup","PBES2_OID","PBKDF2_OID","AES256GCM_OID","AES192GCM_OID","AES128GCM_OID","AES256CBC_OID","AES192CBC_OID","AES128CBC_OID","AES256CFB_OID","AES192CFB_OID","AES128CFB_OID","SHA512_OID","SHA384_OID","SHA256_OID","SHA1_OID","RSA_OID","EC_OID","P256_OID","P384_OID","P521_OID","Utils","_randomInteger","bottom","top","max","min","Number","MAX_SAFE_INTEGER","floor","getRandomValues","Uint32Array","clone","o","structuredClone","frozenClone","freeze","sleep","ms","Promise","resolve","setTimeout","unique","len","base","u","SEnclave","crypt","constructor","encodeAb","arrayBuffer","bytes","base64","substring","decodeAb","encoded1","encoded2","encoded3","encoded4","bufferLength","p","ArrayBuffer","arrayBufferToString","TypeError","TextDecoder","decode","stringToArrayBuffer","str","TextEncoder","encode","buffer","arrayBufferToHexString","byteArray","nextHexByte","hexString","byteLength","toString","hexStringToArrayBuffer","RangeError","parseInt","arrayBufferToBase64","this","base64ToArrayBuffer","b64","decimalToHex","d","unsigned","h","addNewLines","finalString","removeLines","toAsn1","wrappedKey","salt","iv","iterations","hash","cipher","opt","HASH_OID","CIPHER_OID","ITER_INTEGER","SALT_OCTET","IV_OCTET","KEY_OCTET","SEQUENCE_AES_CONTAINER","SEQUENCE_HASH_CONTAINER","SEQUENCE_PBKDF2_INNER_CONTAINER","SEQUENCE_PBKDF2_CONTAINER","SEQUENCE_PBES2_INNER_CONTAINER","SEQUENCE_PBES2_CONTAINER","SEQUENCE_PARAMETERS","SEQUENCE_LENGTH","SEQUENCE","asnKey","pemKey","fromAsn1","pem","hex","includes","valid","saltBegin","indexOf","ivBegin","saltLength","substr","ivLength","iterBegin","iterLength","iter","sequencePadding","parametersPadding","sequenceLength","encryptedDataBegin","encryptedDataPadding","encryptedDataLength","encryptedData","cryptoPrivateToPem","privateKey","self","reject","type","exportKey","then","exportedPrivateKey","catch","err","pemPrivateToCrypto","options","isExtractable","keyOptions","name","curve","usages","namedCurve","importKey","importedPrivateKey","cryptoPublicToPem","publicKey","exportedPublicKey","pemPublicToCrypto","importedPublicKey","cryptoToBase64","key","keyType","exportedKey","b64Key","base64ToCrypto","abKey","importedKey","getRSAKeyPair","modulusLength","paddingScheme","generateKey","publicExponent","keyPair","rsaEncrypt","encrypt","encryptedDataAb","encryptedDataB64","rsaDecrypt","decrypt","decryptedDataAb","getECKeyPair","getPublicKey","jwkKey","algorithm","key_ops","dp","dq","q","qi","encryptPrivateKey","passphrase","passphraseAb","baseKey","deriveKey","derivedKey","wrapKey","tagLength","decryptPrivateKey","encryptedPrivateKey","epki","unwrapKey","unwrappedKey","keyAgreement","bitLength","hkdfHash","hkdfSalt","hkdfInfo","deriveBits","public","derivedBits","info","sharedKey","getSharedKey","encryptKey","wrappingKey","ivAb","encryptedKey","decryptKey","unwrappingKey","ivB64","encryptedKeyB64","encryptedKeyAb","decryptedKey","signKey","keyAb","sign","signatureAb","signatureB64","verifyKey","signature","verify","isValid","encryptedAb","encryptedB64","derivePassphraseKey","hashPassphrase","exportedKeyAb","derivedHash","getFingerprint","isBuffer","digest","fingerprintAb","hexFingerprint","getRandomBytes","size","_state","_keystore","_prvstore","_resetObject","obj","_resetMemory","assign","version","user","state","deviceId","sessionId","_setState","console","_generateRecoveryKey","parts","_removePemHeaders","async","_createAccountKeys","email","password","iKeyPair","ePrvKey","ePubKey","hPwd","passwordHash","_passwordHash","cRecKey","sRecKey","iPemPrvKey","iRec","JSON","stringify","ts","Date","now","iPrvKey","rPass","iKey","eRec","iShrKey","eShrKey","_concatArrayBuffers","buffers","l","arguments","arg","bytea","pos","set","_encryptRaw","edata","_key","ex","error","_decryptRaw","slice","_encrypt","encodetype","ab","encryptRaw","_decrypt","abdata","decryptRaw","parse","_encryptProps","nobj","fn","prop","nprop","_decryptProps","defineProperty","get","signup","code","ekeys","signin","signinLock","keys","iPubKey","_decryptUserKeys","k","ready","logout","generateEncryptedKey","create","ekey","eKey","extractable","_decryptKey","se","bind","encryptProps","decryptProps"],"mappings":"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"}